{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "layout-plugin",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "dependencies": [
    "@lexical/utils"
  ],
  "registryDependencies": [
    "button",
    "select",
    "https://shadcn-editor.vercel.app/r/toolbar-plugin.json"
  ],
  "files": [
    {
      "path": "editor/plugins/layout-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport * as React from 'react'\r\nimport { useState, useEffect, JSX } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport {\r\n  $findMatchingParent,\r\n  $insertNodeToNearestRoot,\r\n  mergeRegister,\r\n} from '@lexical/utils'\r\nimport { LexicalEditor } from 'lexical'\r\nimport type { ElementNode, LexicalCommand, LexicalNode, NodeKey } from 'lexical'\r\nimport {\r\n  $createParagraphNode,\r\n  $getNodeByKey,\r\n  $getSelection,\r\n  $isRangeSelection,\r\n  COMMAND_PRIORITY_EDITOR,\r\n  COMMAND_PRIORITY_LOW,\r\n  KEY_ARROW_DOWN_COMMAND,\r\n  KEY_ARROW_LEFT_COMMAND,\r\n  KEY_ARROW_RIGHT_COMMAND,\r\n  KEY_ARROW_UP_COMMAND,\r\n  createCommand,\r\n} from 'lexical'\r\n\r\nimport { Button } from '@/registry/default/ui/button'\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from '@/registry/default/ui/select'\r\n\r\nimport {\r\n  $createLayoutContainerNode,\r\n  $isLayoutContainerNode,\r\n  LayoutContainerNode,\r\n} from '@/registry/default/editor/nodes/layout-container-node'\r\nimport {\r\n  $createLayoutItemNode,\r\n  $isLayoutItemNode,\r\n  LayoutItemNode,\r\n} from '@/registry/default/editor/nodes/layout-item-node'\r\n\r\nconst LAYOUTS = [\r\n  { label: '2 columns (equal width)', value: '1fr 1fr' },\r\n  { label: '2 columns (25% - 75%)', value: '1fr 3fr' },\r\n  { label: '3 columns (equal width)', value: '1fr 1fr 1fr' },\r\n  { label: '3 columns (25% - 50% - 25%)', value: '1fr 2fr 1fr' },\r\n  { label: '4 columns (equal width)', value: '1fr 1fr 1fr 1fr' },\r\n]\r\n\r\nexport function InsertLayoutDialog({\r\n  activeEditor,\r\n  onClose,\r\n}: {\r\n  activeEditor: LexicalEditor\r\n  onClose: () => void\r\n}): JSX.Element {\r\n  const [layout, setLayout] = useState(LAYOUTS[0].value)\r\n  const buttonLabel = LAYOUTS.find((item) => item.value === layout)?.label\r\n\r\n  const onClick = () => {\r\n    activeEditor.dispatchCommand(INSERT_LAYOUT_COMMAND, layout)\r\n    onClose()\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <Select onValueChange={setLayout} defaultValue={layout}>\r\n        <SelectTrigger className=\"w-full\">\r\n          <SelectValue placeholder={buttonLabel} />\r\n        </SelectTrigger>\r\n        <SelectContent className=\"w-full\">\r\n          {LAYOUTS.map(({ label, value }) => (\r\n            <SelectItem key={value} value={value}>\r\n              {label}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n      <Button onClick={onClick}>Insert</Button>\r\n    </>\r\n  )\r\n}\r\n\r\nexport const INSERT_LAYOUT_COMMAND: LexicalCommand<string> =\r\n  createCommand<string>()\r\n\r\nexport const UPDATE_LAYOUT_COMMAND: LexicalCommand<{\r\n  template: string\r\n  nodeKey: NodeKey\r\n}> = createCommand<{ template: string; nodeKey: NodeKey }>()\r\n\r\nexport function LayoutPlugin(): null {\r\n  const [editor] = useLexicalComposerContext()\r\n  useEffect(() => {\r\n    if (!editor.hasNodes([LayoutContainerNode, LayoutItemNode])) {\r\n      throw new Error(\r\n        'LayoutPlugin: LayoutContainerNode, or LayoutItemNode not registered on editor'\r\n      )\r\n    }\r\n\r\n    const $onEscape = (before: boolean) => {\r\n      const selection = $getSelection()\r\n      if (\r\n        $isRangeSelection(selection) &&\r\n        selection.isCollapsed() &&\r\n        selection.anchor.offset === 0\r\n      ) {\r\n        const container = $findMatchingParent(\r\n          selection.anchor.getNode(),\r\n          $isLayoutContainerNode\r\n        )\r\n\r\n        if ($isLayoutContainerNode(container)) {\r\n          const parent = container.getParent<ElementNode>()\r\n          const child =\r\n            parent &&\r\n            (before\r\n              ? parent.getFirstChild<LexicalNode>()\r\n              : parent?.getLastChild<LexicalNode>())\r\n          const descendant = before\r\n            ? container.getFirstDescendant<LexicalNode>()?.getKey()\r\n            : container.getLastDescendant<LexicalNode>()?.getKey()\r\n\r\n          if (\r\n            parent !== null &&\r\n            child === container &&\r\n            selection.anchor.key === descendant\r\n          ) {\r\n            if (before) {\r\n              container.insertBefore($createParagraphNode())\r\n            } else {\r\n              container.insertAfter($createParagraphNode())\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    return mergeRegister(\r\n      // When layout is the last child pressing down/right arrow will insert paragraph\r\n      // below it to allow adding more content. It's similar what $insertBlockNode\r\n      // (mainly for decorators), except it'll always be possible to continue adding\r\n      // new content even if trailing paragraph is accidentally deleted\r\n      editor.registerCommand(\r\n        KEY_ARROW_DOWN_COMMAND,\r\n        () => $onEscape(false),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        KEY_ARROW_RIGHT_COMMAND,\r\n        () => $onEscape(false),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      // When layout is the first child pressing up/left arrow will insert paragraph\r\n      // above it to allow adding more content. It's similar what $insertBlockNode\r\n      // (mainly for decorators), except it'll always be possible to continue adding\r\n      // new content even if leading paragraph is accidentally deleted\r\n      editor.registerCommand(\r\n        KEY_ARROW_UP_COMMAND,\r\n        () => $onEscape(true),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        KEY_ARROW_LEFT_COMMAND,\r\n        () => $onEscape(true),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        INSERT_LAYOUT_COMMAND,\r\n        (template) => {\r\n          editor.update(() => {\r\n            const container = $createLayoutContainerNode(template)\r\n            const itemsCount = getItemsCountFromTemplate(template)\r\n\r\n            for (let i = 0; i < itemsCount; i++) {\r\n              container.append(\r\n                $createLayoutItemNode().append($createParagraphNode())\r\n              )\r\n            }\r\n\r\n            $insertNodeToNearestRoot(container)\r\n            container.selectStart()\r\n          })\r\n\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_EDITOR\r\n      ),\r\n      editor.registerCommand(\r\n        UPDATE_LAYOUT_COMMAND,\r\n        ({ template, nodeKey }) => {\r\n          editor.update(() => {\r\n            const container = $getNodeByKey<LexicalNode>(nodeKey)\r\n\r\n            if (!$isLayoutContainerNode(container)) {\r\n              return\r\n            }\r\n\r\n            const itemsCount = getItemsCountFromTemplate(template)\r\n            const prevItemsCount = getItemsCountFromTemplate(\r\n              container.getTemplateColumns()\r\n            )\r\n\r\n            // Add or remove extra columns if new template does not match existing one\r\n            if (itemsCount > prevItemsCount) {\r\n              for (let i = prevItemsCount; i < itemsCount; i++) {\r\n                container.append(\r\n                  $createLayoutItemNode().append($createParagraphNode())\r\n                )\r\n              }\r\n            } else if (itemsCount < prevItemsCount) {\r\n              for (let i = prevItemsCount - 1; i >= itemsCount; i--) {\r\n                const layoutItem = container.getChildAtIndex<LexicalNode>(i)\r\n\r\n                if ($isLayoutItemNode(layoutItem)) {\r\n                  layoutItem.remove()\r\n                }\r\n              }\r\n            }\r\n\r\n            container.setTemplateColumns(template)\r\n          })\r\n\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_EDITOR\r\n      ),\r\n      // Structure enforcing transformers for each node type. In case nesting structure is not\r\n      // \"Container > Item\" it'll unwrap nodes and convert it back\r\n      // to regular content.\r\n      editor.registerNodeTransform(LayoutItemNode, (node) => {\r\n        const parent = node.getParent<ElementNode>()\r\n        if (!$isLayoutContainerNode(parent)) {\r\n          const children = node.getChildren<LexicalNode>()\r\n          for (const child of children) {\r\n            node.insertBefore(child)\r\n          }\r\n          node.remove()\r\n        }\r\n      }),\r\n      editor.registerNodeTransform(LayoutContainerNode, (node) => {\r\n        const children = node.getChildren<LexicalNode>()\r\n        if (!children.every($isLayoutItemNode)) {\r\n          for (const child of children) {\r\n            node.insertBefore(child)\r\n          }\r\n          node.remove()\r\n        }\r\n      })\r\n    )\r\n  }, [editor])\r\n\r\n  return null\r\n}\r\n\r\nfunction getItemsCountFromTemplate(template: string): number {\r\n  return template.trim().split(/\\s+/).length\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/layout-plugin.tsx"
    },
    {
      "path": "editor/nodes/layout-container-node.tsx",
      "content": "import { addClassNamesToElement } from '@lexical/utils'\r\nimport type {\r\n  DOMConversionMap,\r\n  DOMConversionOutput,\r\n  DOMExportOutput,\r\n  EditorConfig,\r\n  LexicalNode,\r\n  NodeKey,\r\n  SerializedElementNode,\r\n  Spread,\r\n} from 'lexical'\r\nimport { ElementNode } from 'lexical'\r\n\r\nexport type SerializedLayoutContainerNode = Spread<\r\n  {\r\n    templateColumns: string\r\n  },\r\n  SerializedElementNode\r\n>\r\n\r\nfunction $convertLayoutContainerElement(\r\n  domNode: HTMLElement\r\n): DOMConversionOutput | null {\r\n  const styleAttributes = window.getComputedStyle(domNode)\r\n  const templateColumns = styleAttributes.getPropertyValue(\r\n    'grid-template-columns'\r\n  )\r\n  if (templateColumns) {\r\n    const node = $createLayoutContainerNode(templateColumns)\r\n    return { node }\r\n  }\r\n  return null\r\n}\r\n\r\nexport class LayoutContainerNode extends ElementNode {\r\n  __templateColumns: string\r\n\r\n  constructor(templateColumns: string, key?: NodeKey) {\r\n    super(key)\r\n    this.__templateColumns = templateColumns\r\n  }\r\n\r\n  static getType(): string {\r\n    return 'layout-container'\r\n  }\r\n\r\n  static clone(node: LayoutContainerNode): LayoutContainerNode {\r\n    return new LayoutContainerNode(node.__templateColumns, node.__key)\r\n  }\r\n\r\n  createDOM(config: EditorConfig): HTMLElement {\r\n    const dom = document.createElement('div')\r\n    dom.style.gridTemplateColumns = this.__templateColumns\r\n    if (typeof config.theme.layoutContainer === 'string') {\r\n      addClassNamesToElement(dom, config.theme.layoutContainer)\r\n    }\r\n    return dom\r\n  }\r\n\r\n  exportDOM(): DOMExportOutput {\r\n    const element = document.createElement('div')\r\n    element.style.gridTemplateColumns = this.__templateColumns\r\n    element.setAttribute('data-lexical-layout-container', 'true')\r\n    return { element }\r\n  }\r\n\r\n  updateDOM(prevNode: LayoutContainerNode, dom: HTMLElement): boolean {\r\n    if (prevNode.__templateColumns !== this.__templateColumns) {\r\n      dom.style.gridTemplateColumns = this.__templateColumns\r\n    }\r\n    return false\r\n  }\r\n\r\n  static importDOM(): DOMConversionMap | null {\r\n    return {\r\n      div: (domNode: HTMLElement) => {\r\n        if (!domNode.hasAttribute('data-lexical-layout-container')) {\r\n          return null\r\n        }\r\n        return {\r\n          conversion: $convertLayoutContainerElement,\r\n          priority: 2,\r\n        }\r\n      },\r\n    }\r\n  }\r\n\r\n  static importJSON(json: SerializedLayoutContainerNode): LayoutContainerNode {\r\n    return $createLayoutContainerNode(json.templateColumns)\r\n  }\r\n\r\n  isShadowRoot(): boolean {\r\n    return true\r\n  }\r\n\r\n  canBeEmpty(): boolean {\r\n    return false\r\n  }\r\n\r\n  exportJSON(): SerializedLayoutContainerNode {\r\n    return {\r\n      ...super.exportJSON(),\r\n      templateColumns: this.__templateColumns,\r\n      type: 'layout-container',\r\n      version: 1,\r\n    }\r\n  }\r\n\r\n  getTemplateColumns(): string {\r\n    return this.getLatest().__templateColumns\r\n  }\r\n\r\n  setTemplateColumns(templateColumns: string) {\r\n    this.getWritable().__templateColumns = templateColumns\r\n  }\r\n}\r\n\r\nexport function $createLayoutContainerNode(\r\n  templateColumns: string\r\n): LayoutContainerNode {\r\n  return new LayoutContainerNode(templateColumns)\r\n}\r\n\r\nexport function $isLayoutContainerNode(\r\n  node: LexicalNode | null | undefined\r\n): node is LayoutContainerNode {\r\n  return node instanceof LayoutContainerNode\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/nodes/layout-container-node.tsx"
    },
    {
      "path": "editor/nodes/layout-item-node.tsx",
      "content": "import { addClassNamesToElement } from '@lexical/utils'\r\nimport type {\r\n  DOMConversionMap,\r\n  EditorConfig,\r\n  LexicalNode,\r\n  SerializedElementNode,\r\n} from 'lexical'\r\nimport { ElementNode } from 'lexical'\r\n\r\nexport type SerializedLayoutItemNode = SerializedElementNode\r\n\r\nexport class LayoutItemNode extends ElementNode {\r\n  static getType(): string {\r\n    return 'layout-item'\r\n  }\r\n\r\n  static clone(node: LayoutItemNode): LayoutItemNode {\r\n    return new LayoutItemNode(node.__key)\r\n  }\r\n\r\n  createDOM(config: EditorConfig): HTMLElement {\r\n    const dom = document.createElement('div')\r\n    if (typeof config.theme.layoutItem === 'string') {\r\n      addClassNamesToElement(dom, config.theme.layoutItem)\r\n    }\r\n    return dom\r\n  }\r\n\r\n  updateDOM(): boolean {\r\n    return false\r\n  }\r\n\r\n  static importDOM(): DOMConversionMap | null {\r\n    return {}\r\n  }\r\n\r\n  static importJSON(): LayoutItemNode {\r\n    return $createLayoutItemNode()\r\n  }\r\n\r\n  isShadowRoot(): boolean {\r\n    return true\r\n  }\r\n\r\n  exportJSON(): SerializedLayoutItemNode {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'layout-item',\r\n      version: 1,\r\n    }\r\n  }\r\n}\r\n\r\nexport function $createLayoutItemNode(): LayoutItemNode {\r\n  return new LayoutItemNode()\r\n}\r\n\r\nexport function $isLayoutItemNode(\r\n  node: LexicalNode | null | undefined\r\n): node is LayoutItemNode {\r\n  return node instanceof LayoutItemNode\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/nodes/layout-item-node.tsx"
    },
    {
      "path": "editor/plugins/toolbar/block-insert/insert-columns-layout.tsx",
      "content": "'use client'\r\n\r\nimport { Columns3Icon } from 'lucide-react'\r\n\r\nimport { useToolbarContext } from '@/registry/default/editor/context/toolbar-context'\r\nimport { SelectItem } from '@/registry/default/ui/select'\r\n\r\nimport { InsertLayoutDialog } from '@/registry/default/editor/plugins/layout-plugin'\r\n\r\nexport function InsertColumnsLayout() {\r\n  const { activeEditor, showModal } = useToolbarContext()\r\n\r\n  return (\r\n    <SelectItem\r\n      value=\"columns\"\r\n      onPointerUp={() =>\r\n        showModal('Insert Columns Layout', (onClose) => (\r\n          <InsertLayoutDialog activeEditor={activeEditor} onClose={onClose} />\r\n        ))\r\n      }\r\n      className=\"\"\r\n    >\r\n      <div className=\"flex items-center gap-1\">\r\n        <Columns3Icon className=\"size-4\" />\r\n        <span>Columns Layout</span>\r\n      </div>\r\n    </SelectItem>\r\n  )\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-columns-layout.tsx"
    }
  ]
}