{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auto-embed-plugin",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "dependencies": [
    "@lexical/utils",
    "@lexical/markdown"
  ],
  "registryDependencies": [
    "button",
    "command",
    "dialog",
    "input",
    "popover",
    "select",
    "https://shadcn-editor.vercel.app/r/toolbar-plugin.json"
  ],
  "files": [
    {
      "path": "editor/plugins/embeds/auto-embed-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useMemo, useState, JSX } from 'react'\r\n\r\nimport {\r\n  AutoEmbedOption,\r\n  EmbedConfig,\r\n  EmbedMatchResult,\r\n  LexicalAutoEmbedPlugin,\r\n  URL_MATCHER,\r\n} from '@lexical/react/LexicalAutoEmbedPlugin'\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport { PopoverPortal } from '@radix-ui/react-popover'\r\nimport type { LexicalEditor } from 'lexical'\r\nimport { FigmaIcon, TwitterIcon, YoutubeIcon } from 'lucide-react'\r\n\r\nimport { Button } from '@/registry/default/ui/button'\r\nimport {\r\n  Command,\r\n  CommandGroup,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/registry/default/ui/command'\r\nimport { DialogFooter } from '@/registry/default/ui/dialog'\r\nimport { Input } from '@/registry/default/ui/input'\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/registry/default/ui/popover'\r\n\r\nimport { useEditorModal } from '@/registry/default/editor/editor-hooks/use-modal'\r\nimport { INSERT_FIGMA_COMMAND } from '@/registry/default/editor/plugins/embeds/figma-plugin'\r\nimport { INSERT_TWEET_COMMAND } from '@/registry/default/editor/plugins/embeds/twitter-plugin'\r\nimport { INSERT_YOUTUBE_COMMAND } from '@/registry/default/editor/plugins/embeds/youtube-plugin'\r\n\r\nexport interface CustomEmbedConfig extends EmbedConfig {\r\n  // Human readable name of the embeded content e.g. Tweet or Google Map.\r\n  contentName: string\r\n\r\n  // Icon for display.\r\n  icon?: JSX.Element\r\n\r\n  // An example of a matching url https://twitter.com/jack/status/20\r\n  exampleUrl: string\r\n\r\n  // For extra searching.\r\n  keywords: Array<string>\r\n\r\n  // Embed a Figma Project.\r\n  description?: string\r\n}\r\n\r\nexport const YoutubeEmbedConfig: CustomEmbedConfig = {\r\n  contentName: 'Youtube Video',\r\n\r\n  exampleUrl: 'https://www.youtube.com/watch?v=jNQXAC9IVRw',\r\n\r\n  // Icon for display.\r\n  icon: <YoutubeIcon className=\"size-4\" />,\r\n\r\n  insertNode: (editor: LexicalEditor, result: EmbedMatchResult) => {\r\n    editor.dispatchCommand(INSERT_YOUTUBE_COMMAND, result.id)\r\n  },\r\n\r\n  keywords: ['youtube', 'video'],\r\n\r\n  // Determine if a given URL is a match and return url data.\r\n  parseUrl: async (url: string) => {\r\n    const match =\r\n      /^.*(youtu\\.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/.exec(url)\r\n\r\n    const id = match ? (match?.[2].length === 11 ? match[2] : null) : null\r\n\r\n    if (id != null) {\r\n      return {\r\n        id,\r\n        url,\r\n      }\r\n    }\r\n\r\n    return null\r\n  },\r\n\r\n  type: 'youtube-video',\r\n}\r\n\r\nexport const TwitterEmbedConfig: CustomEmbedConfig = {\r\n  // e.g. Tweet or Google Map.\r\n  contentName: 'Tweet',\r\n\r\n  exampleUrl: 'https://twitter.com/jack/status/20',\r\n\r\n  // Icon for display.\r\n  icon: <TwitterIcon className=\"size-4\" />,\r\n\r\n  // Create the Lexical embed node from the url data.\r\n  insertNode: (editor: LexicalEditor, result: EmbedMatchResult) => {\r\n    editor.dispatchCommand(INSERT_TWEET_COMMAND, result.id)\r\n  },\r\n\r\n  // For extra searching.\r\n  keywords: ['tweet', 'twitter'],\r\n\r\n  // Determine if a given URL is a match and return url data.\r\n  parseUrl: (text: string) => {\r\n    const match =\r\n      /^https:\\/\\/(twitter|x)\\.com\\/(#!\\/)?(\\w+)\\/status(es)*\\/(\\d+)/.exec(text)\r\n\r\n    if (match != null) {\r\n      return {\r\n        id: match[5],\r\n        url: match[1],\r\n      }\r\n    }\r\n\r\n    return null\r\n  },\r\n\r\n  type: 'tweet',\r\n}\r\n\r\nexport const FigmaEmbedConfig: CustomEmbedConfig = {\r\n  contentName: 'Figma Document',\r\n\r\n  exampleUrl: 'https://www.figma.com/file/LKQ4FJ4bTnCSjedbRpk931/Sample-File',\r\n\r\n  icon: <FigmaIcon className=\"size-4\" />,\r\n\r\n  insertNode: (editor: LexicalEditor, result: EmbedMatchResult) => {\r\n    editor.dispatchCommand(INSERT_FIGMA_COMMAND, result.id)\r\n  },\r\n\r\n  keywords: ['figma', 'figma.com', 'mock-up'],\r\n\r\n  // Determine if a given URL is a match and return url data.\r\n  parseUrl: (text: string) => {\r\n    const match =\r\n      /https:\\/\\/([\\w.-]+\\.)?figma.com\\/(file|proto)\\/([0-9a-zA-Z]{22,128})(?:\\/.*)?$/.exec(\r\n        text\r\n      )\r\n\r\n    if (match != null) {\r\n      return {\r\n        id: match[3],\r\n        url: match[0],\r\n      }\r\n    }\r\n\r\n    return null\r\n  },\r\n\r\n  type: 'figma',\r\n}\r\n\r\nexport const EmbedConfigs = [\r\n  TwitterEmbedConfig,\r\n  YoutubeEmbedConfig,\r\n  FigmaEmbedConfig,\r\n]\r\n\r\nconst debounce = (callback: (text: string) => void, delay: number) => {\r\n  let timeoutId: number\r\n  return (text: string) => {\r\n    window.clearTimeout(timeoutId)\r\n    timeoutId = window.setTimeout(() => {\r\n      callback(text)\r\n    }, delay)\r\n  }\r\n}\r\n\r\nexport function AutoEmbedDialog({\r\n  embedConfig,\r\n  onClose,\r\n}: {\r\n  embedConfig: CustomEmbedConfig\r\n  onClose: () => void\r\n}): JSX.Element {\r\n  const [text, setText] = useState('')\r\n  const [editor] = useLexicalComposerContext()\r\n  const [embedResult, setEmbedResult] = useState<EmbedMatchResult | null>(null)\r\n\r\n  const validateText = useMemo(\r\n    () =>\r\n      debounce((inputText: string) => {\r\n        const urlMatch = URL_MATCHER.exec(inputText)\r\n        if (embedConfig != null && inputText != null && urlMatch != null) {\r\n          Promise.resolve(embedConfig.parseUrl(inputText)).then(\r\n            (parseResult) => {\r\n              setEmbedResult(parseResult)\r\n            }\r\n          )\r\n        } else if (embedResult != null) {\r\n          setEmbedResult(null)\r\n        }\r\n      }, 200),\r\n    [embedConfig, embedResult]\r\n  )\r\n\r\n  const onClick = () => {\r\n    if (embedResult != null) {\r\n      embedConfig.insertNode(editor, embedResult)\r\n      onClose()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"\">\r\n      <div className=\"space-y-4\">\r\n        <Input\r\n          type=\"text\"\r\n          placeholder={embedConfig.exampleUrl}\r\n          value={text}\r\n          data-test-id={`${embedConfig.type}-embed-modal-url`}\r\n          onChange={(e) => {\r\n            const { value } = e.target\r\n            setText(value)\r\n            validateText(value)\r\n          }}\r\n        />\r\n        <DialogFooter>\r\n          <Button\r\n            disabled={!embedResult}\r\n            onClick={onClick}\r\n            data-test-id={`${embedConfig.type}-embed-modal-submit-btn`}\r\n          >\r\n            Embed\r\n          </Button>\r\n        </DialogFooter>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function AutoEmbedPlugin(): JSX.Element {\r\n  const [modal, showModal] = useEditorModal()\r\n\r\n  const openEmbedModal = (embedConfig: CustomEmbedConfig) => {\r\n    showModal(`Embed ${embedConfig.contentName}`, (onClose) => (\r\n      <AutoEmbedDialog embedConfig={embedConfig} onClose={onClose} />\r\n    ))\r\n  }\r\n\r\n  const getMenuOptions = (\r\n    activeEmbedConfig: CustomEmbedConfig,\r\n    embedFn: () => void,\r\n    dismissFn: () => void\r\n  ) => {\r\n    return [\r\n      new AutoEmbedOption('Dismiss', {\r\n        onSelect: dismissFn,\r\n      }),\r\n      new AutoEmbedOption(`Embed ${activeEmbedConfig.contentName}`, {\r\n        onSelect: embedFn,\r\n      }),\r\n    ]\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {modal}\r\n      <LexicalAutoEmbedPlugin<CustomEmbedConfig>\r\n        embedConfigs={EmbedConfigs}\r\n        onOpenEmbedModalForConfig={openEmbedModal}\r\n        getMenuOptions={getMenuOptions}\r\n        menuRenderFn={(\r\n          anchorElementRef,\r\n          {\r\n            selectedIndex,\r\n            options,\r\n            selectOptionAndCleanUp,\r\n            setHighlightedIndex,\r\n          }\r\n        ) => {\r\n          return anchorElementRef.current ? (\r\n            <Popover open={true}>\r\n              <PopoverPortal container={anchorElementRef.current}>\r\n                <div className=\"-translate-y-full transform\">\r\n                  <PopoverTrigger />\r\n                  <PopoverContent\r\n                    className=\"w-[200px] p-0\"\r\n                    align=\"start\"\r\n                    side=\"right\"\r\n                  >\r\n                    <Command>\r\n                      <CommandList>\r\n                        <CommandGroup>\r\n                          {options.map((option, i: number) => (\r\n                            <CommandItem\r\n                              key={option.key}\r\n                              value={option.title}\r\n                              onSelect={() => {\r\n                                selectOptionAndCleanUp(option)\r\n                              }}\r\n                              className=\"flex items-center gap-2\"\r\n                            >\r\n                              {option.title}\r\n                            </CommandItem>\r\n                          ))}\r\n                        </CommandGroup>\r\n                      </CommandList>\r\n                    </Command>\r\n                  </PopoverContent>\r\n                </div>\r\n              </PopoverPortal>\r\n            </Popover>\r\n          ) : null\r\n        }}\r\n      />\r\n    </>\r\n  )\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/auto-embed-plugin.tsx"
    },
    {
      "path": "editor/plugins/embeds/figma-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useEffect, JSX } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport { $insertNodeToNearestRoot } from '@lexical/utils'\r\nimport { COMMAND_PRIORITY_EDITOR, LexicalCommand, createCommand } from 'lexical'\r\n\r\nimport { $createFigmaNode, FigmaNode } from '@/registry/default/editor/nodes/embeds/figma-node'\r\n\r\nexport const INSERT_FIGMA_COMMAND: LexicalCommand<string> = createCommand(\r\n  'INSERT_FIGMA_COMMAND'\r\n)\r\n\r\nexport function FigmaPlugin(): JSX.Element | null {\r\n  const [editor] = useLexicalComposerContext()\r\n\r\n  useEffect(() => {\r\n    if (!editor.hasNodes([FigmaNode])) {\r\n      throw new Error('FigmaPlugin: FigmaNode not registered on editor')\r\n    }\r\n\r\n    return editor.registerCommand<string>(\r\n      INSERT_FIGMA_COMMAND,\r\n      (payload) => {\r\n        const figmaNode = $createFigmaNode(payload)\r\n        $insertNodeToNearestRoot(figmaNode)\r\n        return true\r\n      },\r\n      COMMAND_PRIORITY_EDITOR\r\n    )\r\n  }, [editor])\r\n\r\n  return null\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/figma-plugin.tsx"
    },
    {
      "path": "editor/nodes/embeds/figma-node.tsx",
      "content": "import * as React from 'react'\r\nimport { JSX } from 'react'\r\n\r\nimport { BlockWithAlignableContents } from '@lexical/react/LexicalBlockWithAlignableContents'\r\nimport {\r\n  DecoratorBlockNode,\r\n  SerializedDecoratorBlockNode,\r\n} from '@lexical/react/LexicalDecoratorBlockNode'\r\nimport type {\r\n  EditorConfig,\r\n  ElementFormatType,\r\n  LexicalEditor,\r\n  LexicalNode,\r\n  NodeKey,\r\n  Spread,\r\n} from 'lexical'\r\n\r\ntype FigmaComponentProps = Readonly<{\r\n  className: Readonly<{\r\n    base: string\r\n    focus: string\r\n  }>\r\n  format: ElementFormatType | null\r\n  nodeKey: NodeKey\r\n  documentID: string\r\n}>\r\n\r\nfunction FigmaComponent({\r\n  className,\r\n  format,\r\n  nodeKey,\r\n  documentID,\r\n}: FigmaComponentProps) {\r\n  return (\r\n    <BlockWithAlignableContents\r\n      className={className}\r\n      format={format}\r\n      nodeKey={nodeKey}\r\n    >\r\n      <iframe\r\n        width=\"560\"\r\n        height=\"315\"\r\n        src={`https://www.figma.com/embed?embed_host=lexical&url=\\\r\n        https://www.figma.com/file/${documentID}`}\r\n        allowFullScreen={true}\r\n      />\r\n    </BlockWithAlignableContents>\r\n  )\r\n}\r\n\r\nexport type SerializedFigmaNode = Spread<\r\n  {\r\n    documentID: string\r\n  },\r\n  SerializedDecoratorBlockNode\r\n>\r\n\r\nexport class FigmaNode extends DecoratorBlockNode {\r\n  __id: string\r\n\r\n  static getType(): string {\r\n    return 'figma'\r\n  }\r\n\r\n  static clone(node: FigmaNode): FigmaNode {\r\n    return new FigmaNode(node.__id, node.__format, node.__key)\r\n  }\r\n\r\n  static importJSON(serializedNode: SerializedFigmaNode): FigmaNode {\r\n    const node = $createFigmaNode(serializedNode.documentID)\r\n    node.setFormat(serializedNode.format)\r\n    return node\r\n  }\r\n\r\n  exportJSON(): SerializedFigmaNode {\r\n    return {\r\n      ...super.exportJSON(),\r\n      documentID: this.__id,\r\n      type: 'figma',\r\n      version: 1,\r\n    }\r\n  }\r\n\r\n  constructor(id: string, format?: ElementFormatType, key?: NodeKey) {\r\n    super(format, key)\r\n    this.__id = id\r\n  }\r\n\r\n  updateDOM(): false {\r\n    return false\r\n  }\r\n\r\n  getId(): string {\r\n    return this.__id\r\n  }\r\n\r\n  getTextContent(\r\n    _includeInert?: boolean | undefined,\r\n    _includeDirectionless?: false | undefined\r\n  ): string {\r\n    return `https://www.figma.com/file/${this.__id}`\r\n  }\r\n\r\n  decorate(_editor: LexicalEditor, config: EditorConfig): JSX.Element {\r\n    const embedBlockTheme = config.theme.embedBlock || {}\r\n    const className = {\r\n      base: embedBlockTheme.base || '',\r\n      focus: embedBlockTheme.focus || '',\r\n    }\r\n    return (\r\n      <FigmaComponent\r\n        className={className}\r\n        format={this.__format}\r\n        nodeKey={this.getKey()}\r\n        documentID={this.__id}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport function $createFigmaNode(documentID: string): FigmaNode {\r\n  return new FigmaNode(documentID)\r\n}\r\n\r\nexport function $isFigmaNode(\r\n  node: FigmaNode | LexicalNode | null | undefined\r\n): node is FigmaNode {\r\n  return node instanceof FigmaNode\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/nodes/embeds/figma-node.tsx"
    },
    {
      "path": "editor/plugins/embeds/twitter-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useEffect, JSX } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport { $insertNodeToNearestRoot } from '@lexical/utils'\r\nimport { COMMAND_PRIORITY_EDITOR, LexicalCommand, createCommand } from 'lexical'\r\n\r\nimport { $createTweetNode, TweetNode } from '@/registry/default/editor/nodes/embeds/tweet-node'\r\n\r\nexport const INSERT_TWEET_COMMAND: LexicalCommand<string> = createCommand(\r\n  'INSERT_TWEET_COMMAND'\r\n)\r\n\r\nexport function TwitterPlugin(): JSX.Element | null {\r\n  const [editor] = useLexicalComposerContext()\r\n\r\n  useEffect(() => {\r\n    if (!editor.hasNodes([TweetNode])) {\r\n      throw new Error('TwitterPlugin: TweetNode not registered on editor')\r\n    }\r\n\r\n    return editor.registerCommand<string>(\r\n      INSERT_TWEET_COMMAND,\r\n      (payload) => {\r\n        const tweetNode = $createTweetNode(payload)\r\n        $insertNodeToNearestRoot(tweetNode)\r\n\r\n        return true\r\n      },\r\n      COMMAND_PRIORITY_EDITOR\r\n    )\r\n  }, [editor])\r\n\r\n  return null\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/twitter-plugin.tsx"
    },
    {
      "path": "editor/nodes/embeds/tweet-node.tsx",
      "content": "import * as React from 'react'\r\nimport { useCallback, useEffect, useRef, useState, JSX } from 'react'\r\n\r\nimport { BlockWithAlignableContents } from '@lexical/react/LexicalBlockWithAlignableContents'\r\nimport {\r\n  DecoratorBlockNode,\r\n  SerializedDecoratorBlockNode,\r\n} from '@lexical/react/LexicalDecoratorBlockNode'\r\nimport type {\r\n  DOMConversionMap,\r\n  DOMConversionOutput,\r\n  DOMExportOutput,\r\n  EditorConfig,\r\n  ElementFormatType,\r\n  LexicalEditor,\r\n  LexicalNode,\r\n  NodeKey,\r\n  Spread,\r\n} from 'lexical'\r\n\r\nconst WIDGET_SCRIPT_URL = 'https://platform.twitter.com/widgets.js'\r\n\r\ntype TweetComponentProps = Readonly<{\r\n  className: Readonly<{\r\n    base: string\r\n    focus: string\r\n  }>\r\n  format: ElementFormatType | null\r\n  loadingComponent?: JSX.Element | string\r\n  nodeKey: NodeKey\r\n  onError?: (error: string) => void\r\n  onLoad?: () => void\r\n  tweetID: string\r\n}>\r\n\r\nfunction $convertTweetElement(\r\n  domNode: HTMLDivElement\r\n): DOMConversionOutput | null {\r\n  const id = domNode.getAttribute('data-lexical-tweet-id')\r\n  if (id) {\r\n    const node = $createTweetNode(id)\r\n    return { node }\r\n  }\r\n  return null\r\n}\r\n\r\nlet isTwitterScriptLoading = true\r\n\r\nfunction TweetComponent({\r\n  className,\r\n  format,\r\n  loadingComponent,\r\n  nodeKey,\r\n  onError,\r\n  onLoad,\r\n  tweetID,\r\n}: TweetComponentProps) {\r\n  const containerRef = useRef<HTMLDivElement | null>(null)\r\n\r\n  const previousTweetIDRef = useRef<string>('')\r\n  const [isTweetLoading, setIsTweetLoading] = useState(false)\r\n\r\n  const createTweet = useCallback(async () => {\r\n    try {\r\n      // @ts-expect-error Twitter is attached to the window.\r\n      await window.twttr.widgets.createTweet(tweetID, containerRef.current)\r\n\r\n      setIsTweetLoading(false)\r\n      isTwitterScriptLoading = false\r\n\r\n      if (onLoad) {\r\n        onLoad()\r\n      }\r\n    } catch (error) {\r\n      if (onError) {\r\n        onError(String(error))\r\n      }\r\n    }\r\n  }, [onError, onLoad, tweetID])\r\n\r\n  useEffect(() => {\r\n    if (tweetID !== previousTweetIDRef.current) {\r\n      setIsTweetLoading(true)\r\n\r\n      if (isTwitterScriptLoading) {\r\n        const script = document.createElement('script')\r\n        script.src = WIDGET_SCRIPT_URL\r\n        script.async = true\r\n        document.body?.appendChild(script)\r\n        script.onload = createTweet\r\n        if (onError) {\r\n          script.onerror = onError as OnErrorEventHandler\r\n        }\r\n      } else {\r\n        createTweet()\r\n      }\r\n\r\n      if (previousTweetIDRef) {\r\n        previousTweetIDRef.current = tweetID\r\n      }\r\n    }\r\n  }, [createTweet, onError, tweetID])\r\n\r\n  return (\r\n    <BlockWithAlignableContents\r\n      className={className}\r\n      format={format}\r\n      nodeKey={nodeKey}\r\n    >\r\n      {isTweetLoading ? loadingComponent : null}\r\n      <div\r\n        style={{ display: 'inline-block', width: '550px' }}\r\n        ref={containerRef}\r\n      />\r\n    </BlockWithAlignableContents>\r\n  )\r\n}\r\n\r\nexport type SerializedTweetNode = Spread<\r\n  {\r\n    id: string\r\n  },\r\n  SerializedDecoratorBlockNode\r\n>\r\n\r\nexport class TweetNode extends DecoratorBlockNode {\r\n  __id: string\r\n\r\n  static getType(): string {\r\n    return 'tweet'\r\n  }\r\n\r\n  static clone(node: TweetNode): TweetNode {\r\n    return new TweetNode(node.__id, node.__format, node.__key)\r\n  }\r\n\r\n  static importJSON(serializedNode: SerializedTweetNode): TweetNode {\r\n    const node = $createTweetNode(serializedNode.id)\r\n    node.setFormat(serializedNode.format)\r\n    return node\r\n  }\r\n\r\n  exportJSON(): SerializedTweetNode {\r\n    return {\r\n      ...super.exportJSON(),\r\n      id: this.getId(),\r\n      type: 'tweet',\r\n      version: 1,\r\n    }\r\n  }\r\n\r\n  static importDOM(): DOMConversionMap<HTMLDivElement> | null {\r\n    return {\r\n      div: (domNode: HTMLDivElement) => {\r\n        if (!domNode.hasAttribute('data-lexical-tweet-id')) {\r\n          return null\r\n        }\r\n        return {\r\n          conversion: $convertTweetElement,\r\n          priority: 2,\r\n        }\r\n      },\r\n    }\r\n  }\r\n\r\n  exportDOM(): DOMExportOutput {\r\n    const element = document.createElement('div')\r\n    element.setAttribute('data-lexical-tweet-id', this.__id)\r\n    const text = document.createTextNode(this.getTextContent())\r\n    element.append(text)\r\n    return { element }\r\n  }\r\n\r\n  constructor(id: string, format?: ElementFormatType, key?: NodeKey) {\r\n    super(format, key)\r\n    this.__id = id\r\n  }\r\n\r\n  getId(): string {\r\n    return this.__id\r\n  }\r\n\r\n  getTextContent(\r\n    _includeInert?: boolean | undefined,\r\n    _includeDirectionless?: false | undefined\r\n  ): string {\r\n    return `https://x.com/i/web/status/${this.__id}`\r\n  }\r\n\r\n  decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\r\n    const embedBlockTheme = config.theme.embedBlock || {}\r\n    const className = {\r\n      base: embedBlockTheme.base || '',\r\n      focus: embedBlockTheme.focus || '',\r\n    }\r\n    return (\r\n      <TweetComponent\r\n        className={className}\r\n        format={this.__format}\r\n        loadingComponent=\"Loading...\"\r\n        nodeKey={this.getKey()}\r\n        tweetID={this.__id}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport function $createTweetNode(tweetID: string): TweetNode {\r\n  return new TweetNode(tweetID)\r\n}\r\n\r\nexport function $isTweetNode(\r\n  node: TweetNode | LexicalNode | null | undefined\r\n): node is TweetNode {\r\n  return node instanceof TweetNode\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/nodes/embeds/tweet-node.tsx"
    },
    {
      "path": "editor/plugins/embeds/youtube-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useEffect, JSX } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport { $insertNodeToNearestRoot } from '@lexical/utils'\r\nimport { COMMAND_PRIORITY_EDITOR, LexicalCommand, createCommand } from 'lexical'\r\n\r\nimport {\r\n  $createYouTubeNode,\r\n  YouTubeNode,\r\n} from '@/registry/default/editor/nodes/embeds/youtube-node'\r\n\r\nexport const INSERT_YOUTUBE_COMMAND: LexicalCommand<string> = createCommand(\r\n  'INSERT_YOUTUBE_COMMAND'\r\n)\r\n\r\nexport function YouTubePlugin(): JSX.Element | null {\r\n  const [editor] = useLexicalComposerContext()\r\n\r\n  useEffect(() => {\r\n    if (!editor.hasNodes([YouTubeNode])) {\r\n      throw new Error('YouTubePlugin: YouTubeNode not registered on editor')\r\n    }\r\n\r\n    return editor.registerCommand<string>(\r\n      INSERT_YOUTUBE_COMMAND,\r\n      (payload) => {\r\n        const youTubeNode = $createYouTubeNode(payload)\r\n        $insertNodeToNearestRoot(youTubeNode)\r\n\r\n        return true\r\n      },\r\n      COMMAND_PRIORITY_EDITOR\r\n    )\r\n  }, [editor])\r\n\r\n  return null\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/youtube-plugin.tsx"
    },
    {
      "path": "editor/nodes/embeds/youtube-node.tsx",
      "content": "import * as React from 'react'\r\nimport { JSX } from 'react'\r\n\r\nimport { BlockWithAlignableContents } from '@lexical/react/LexicalBlockWithAlignableContents'\r\nimport {\r\n  DecoratorBlockNode,\r\n  SerializedDecoratorBlockNode,\r\n} from '@lexical/react/LexicalDecoratorBlockNode'\r\nimport type {\r\n  DOMConversionMap,\r\n  DOMConversionOutput,\r\n  DOMExportOutput,\r\n  EditorConfig,\r\n  ElementFormatType,\r\n  LexicalEditor,\r\n  LexicalNode,\r\n  NodeKey,\r\n  Spread,\r\n} from 'lexical'\r\n\r\ntype YouTubeComponentProps = Readonly<{\r\n  className: Readonly<{\r\n    base: string\r\n    focus: string\r\n  }>\r\n  format: ElementFormatType | null\r\n  nodeKey: NodeKey\r\n  videoID: string\r\n}>\r\n\r\nfunction YouTubeComponent({\r\n  className,\r\n  format,\r\n  nodeKey,\r\n  videoID,\r\n}: YouTubeComponentProps) {\r\n  return (\r\n    <BlockWithAlignableContents\r\n      className={className}\r\n      format={format}\r\n      nodeKey={nodeKey}\r\n    >\r\n      <iframe\r\n        width=\"560\"\r\n        height=\"315\"\r\n        src={`https://www.youtube-nocookie.com/embed/${videoID}`}\r\n        frameBorder=\"0\"\r\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\r\n        allowFullScreen={true}\r\n        title=\"YouTube video\"\r\n      />\r\n    </BlockWithAlignableContents>\r\n  )\r\n}\r\n\r\nexport type SerializedYouTubeNode = Spread<\r\n  {\r\n    videoID: string\r\n  },\r\n  SerializedDecoratorBlockNode\r\n>\r\n\r\nfunction $convertYoutubeElement(\r\n  domNode: HTMLElement\r\n): null | DOMConversionOutput {\r\n  const videoID = domNode.getAttribute('data-lexical-youtube')\r\n  if (videoID) {\r\n    const node = $createYouTubeNode(videoID)\r\n    return { node }\r\n  }\r\n  return null\r\n}\r\n\r\nexport class YouTubeNode extends DecoratorBlockNode {\r\n  __id: string\r\n\r\n  static getType(): string {\r\n    return 'youtube'\r\n  }\r\n\r\n  static clone(node: YouTubeNode): YouTubeNode {\r\n    return new YouTubeNode(node.__id, node.__format, node.__key)\r\n  }\r\n\r\n  static importJSON(serializedNode: SerializedYouTubeNode): YouTubeNode {\r\n    const node = $createYouTubeNode(serializedNode.videoID)\r\n    node.setFormat(serializedNode.format)\r\n    return node\r\n  }\r\n\r\n  exportJSON(): SerializedYouTubeNode {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'youtube',\r\n      version: 1,\r\n      videoID: this.__id,\r\n    }\r\n  }\r\n\r\n  constructor(id: string, format?: ElementFormatType, key?: NodeKey) {\r\n    super(format, key)\r\n    this.__id = id\r\n  }\r\n\r\n  exportDOM(): DOMExportOutput {\r\n    const element = document.createElement('iframe')\r\n    element.setAttribute('data-lexical-youtube', this.__id)\r\n    element.setAttribute('width', '560')\r\n    element.setAttribute('height', '315')\r\n    element.setAttribute(\r\n      'src',\r\n      `https://www.youtube-nocookie.com/embed/${this.__id}`\r\n    )\r\n    element.setAttribute('frameborder', '0')\r\n    element.setAttribute(\r\n      'allow',\r\n      'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture'\r\n    )\r\n    element.setAttribute('allowfullscreen', 'true')\r\n    element.setAttribute('title', 'YouTube video')\r\n    return { element }\r\n  }\r\n\r\n  static importDOM(): DOMConversionMap | null {\r\n    return {\r\n      iframe: (domNode: HTMLElement) => {\r\n        if (!domNode.hasAttribute('data-lexical-youtube')) {\r\n          return null\r\n        }\r\n        return {\r\n          conversion: $convertYoutubeElement,\r\n          priority: 1,\r\n        }\r\n      },\r\n    }\r\n  }\r\n\r\n  updateDOM(): false {\r\n    return false\r\n  }\r\n\r\n  getId(): string {\r\n    return this.__id\r\n  }\r\n\r\n  getTextContent(\r\n    _includeInert?: boolean | undefined,\r\n    _includeDirectionless?: false | undefined\r\n  ): string {\r\n    return `https://www.youtube.com/watch?v=${this.__id}`\r\n  }\r\n\r\n  decorate(_editor: LexicalEditor, config: EditorConfig): JSX.Element {\r\n    const embedBlockTheme = config.theme.embedBlock || {}\r\n    const className = {\r\n      base: embedBlockTheme.base || '',\r\n      focus: embedBlockTheme.focus || '',\r\n    }\r\n    return (\r\n      <YouTubeComponent\r\n        className={className}\r\n        format={this.__format}\r\n        nodeKey={this.getKey()}\r\n        videoID={this.__id}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport function $createYouTubeNode(videoID: string): YouTubeNode {\r\n  return new YouTubeNode(videoID)\r\n}\r\n\r\nexport function $isYouTubeNode(\r\n  node: YouTubeNode | LexicalNode | null | undefined\r\n): node is YouTubeNode {\r\n  return node instanceof YouTubeNode\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/nodes/embeds/youtube-node.tsx"
    },
    {
      "path": "editor/editor-hooks/use-modal.tsx",
      "content": "import { useCallback, useMemo, useState, JSX } from 'react'\r\nimport * as React from 'react'\r\n\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from '@/registry/default/ui/dialog'\r\n\r\nexport function useEditorModal(): [\r\n  JSX.Element | null,\r\n  (title: string, showModal: (onClose: () => void) => JSX.Element) => void,\r\n] {\r\n  const [modalContent, setModalContent] = useState<null | {\r\n    closeOnClickOutside: boolean\r\n    content: JSX.Element\r\n    title: string\r\n  }>(null)\r\n\r\n  const onClose = useCallback(() => {\r\n    setModalContent(null)\r\n  }, [])\r\n\r\n  const modal = useMemo(() => {\r\n    if (modalContent === null) {\r\n      return null\r\n    }\r\n    const { title, content } = modalContent\r\n    return (\r\n      <Dialog open={true} onOpenChange={onClose}>\r\n        <DialogContent>\r\n          <DialogHeader>\r\n            <DialogTitle>{title}</DialogTitle>\r\n          </DialogHeader>\r\n          {content}\r\n        </DialogContent>\r\n      </Dialog>\r\n    )\r\n  }, [modalContent, onClose])\r\n\r\n  const showModal = useCallback(\r\n    (\r\n      title: string,\r\n      getContent: (onClose: () => void) => JSX.Element,\r\n      closeOnClickOutside = false\r\n    ) => {\r\n      setModalContent({\r\n        closeOnClickOutside,\r\n        content: getContent(onClose),\r\n        title,\r\n      })\r\n    },\r\n    [onClose]\r\n  )\r\n\r\n  return [modal, showModal]\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-modal.tsx"
    },
    {
      "path": "editor/transformers/markdown-tweet-transformer.ts",
      "content": "import { ElementTransformer } from '@lexical/markdown'\r\n\r\nimport {\r\n  $createTweetNode,\r\n  $isTweetNode,\r\n  TweetNode,\r\n} from '@/registry/default/editor/nodes/embeds/tweet-node'\r\n\r\nexport const TWEET: ElementTransformer = {\r\n  dependencies: [TweetNode],\r\n  export: (node) => {\r\n    if (!$isTweetNode(node)) {\r\n      return null\r\n    }\r\n\r\n    return `<tweet id=\"${node.getId()}\" />`\r\n  },\r\n  regExp: /<tweet id=\"([^\"]+?)\"\\s?\\/>\\s?$/,\r\n  replace: (textNode, _1, match) => {\r\n    const [, id] = match\r\n    const tweetNode = $createTweetNode(id)\r\n    textNode.replace(tweetNode)\r\n  },\r\n  type: 'element',\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/transformers/markdown-tweet-transformer.ts"
    },
    {
      "path": "editor/plugins/toolbar/block-insert/insert-embeds.tsx",
      "content": "'use client'\r\n\r\nimport { INSERT_EMBED_COMMAND } from '@lexical/react/LexicalAutoEmbedPlugin'\r\n\r\nimport { useToolbarContext } from '@/registry/default/editor/context/toolbar-context'\r\nimport { SelectItem } from '@/registry/default/ui/select'\r\n\r\nimport { EmbedConfigs } from '@/registry/default/editor/plugins/embeds/auto-embed-plugin'\r\n\r\nexport function InsertEmbeds() {\r\n  const { activeEditor } = useToolbarContext()\r\n  return EmbedConfigs.map((embedConfig) => (\r\n    <SelectItem\r\n      key={embedConfig.type}\r\n      value={embedConfig.type}\r\n      onPointerUp={() => {\r\n        activeEditor.dispatchCommand(INSERT_EMBED_COMMAND, embedConfig.type)\r\n      }}\r\n      className=\"\"\r\n    >\r\n      <div className=\"flex items-center gap-1\">\r\n        {embedConfig.icon}\r\n        <span>{embedConfig.contentName}</span>\r\n      </div>\r\n    </SelectItem>\r\n  ))\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-embeds.tsx"
    }
  ]
}