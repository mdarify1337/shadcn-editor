{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "speech-to-text-plugin",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "registryDependencies": [
    "button",
    "tooltip",
    "https://shadcn-editor.vercel.app/r/actions-plugin.json"
  ],
  "files": [
    {
      "path": "editor/plugins/actions/speech-to-text-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useEffect, useRef, useState } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport type { LexicalCommand, LexicalEditor, RangeSelection } from 'lexical'\r\nimport {\r\n  $getSelection,\r\n  $isRangeSelection,\r\n  COMMAND_PRIORITY_EDITOR,\r\n  REDO_COMMAND,\r\n  UNDO_COMMAND,\r\n  createCommand,\r\n} from 'lexical'\r\nimport { MicIcon } from 'lucide-react'\r\n\r\nimport { Button } from '@/registry/default/ui/button'\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipTrigger,\r\n} from '@/registry/default/ui/tooltip'\r\n\r\nimport { useReport } from '@/registry/default/editor/editor-hooks/use-report'\r\nimport { CAN_USE_DOM } from '@/registry/default/editor/shared/can-use-dom'\r\n\r\nexport const SPEECH_TO_TEXT_COMMAND: LexicalCommand<boolean> = createCommand(\r\n  'SPEECH_TO_TEXT_COMMAND'\r\n)\r\n\r\nconst VOICE_COMMANDS: Readonly<\r\n  Record<\r\n    string,\r\n    (arg0: { editor: LexicalEditor; selection: RangeSelection }) => void\r\n  >\r\n> = {\r\n  '\\n': ({ selection }) => {\r\n    selection.insertParagraph()\r\n  },\r\n  redo: ({ editor }) => {\r\n    editor.dispatchCommand(REDO_COMMAND, undefined)\r\n  },\r\n  undo: ({ editor }) => {\r\n    editor.dispatchCommand(UNDO_COMMAND, undefined)\r\n  },\r\n}\r\n\r\nexport const SUPPORT_SPEECH_RECOGNITION: boolean =\r\n  CAN_USE_DOM &&\r\n  ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)\r\n\r\nfunction SpeechToTextPluginImpl() {\r\n  const [editor] = useLexicalComposerContext()\r\n  const [isEnabled, setIsEnabled] = useState<boolean>(false)\r\n  const [isSpeechToText, setIsSpeechToText] = useState<boolean>(false)\r\n  const SpeechRecognition =\r\n    // @ts-expect-error missing type\r\n    CAN_USE_DOM && (window.SpeechRecognition || window.webkitSpeechRecognition)\r\n  const recognition = useRef<typeof SpeechRecognition | null>(null)\r\n  const report = useReport()\r\n\r\n  useEffect(() => {\r\n    if (isEnabled && recognition.current === null) {\r\n      recognition.current = new SpeechRecognition()\r\n      recognition.current.continuous = true\r\n      recognition.current.interimResults = true\r\n      recognition.current.addEventListener(\r\n        'result',\r\n        (event: typeof SpeechRecognition) => {\r\n          const resultItem = event.results.item(event.resultIndex)\r\n          const { transcript } = resultItem.item(0)\r\n          report(transcript)\r\n\r\n          if (!resultItem.isFinal) {\r\n            return\r\n          }\r\n\r\n          editor.update(() => {\r\n            const selection = $getSelection()\r\n\r\n            if ($isRangeSelection(selection)) {\r\n              const command = VOICE_COMMANDS[transcript.toLowerCase().trim()]\r\n\r\n              if (command) {\r\n                command({\r\n                  editor,\r\n                  selection,\r\n                })\r\n              } else if (transcript.match(/\\s*\\n\\s*/)) {\r\n                selection.insertParagraph()\r\n              } else {\r\n                selection.insertText(transcript)\r\n              }\r\n            }\r\n          })\r\n        }\r\n      )\r\n    }\r\n\r\n    if (recognition.current) {\r\n      if (isEnabled) {\r\n        recognition.current.start()\r\n      } else {\r\n        recognition.current.stop()\r\n      }\r\n    }\r\n\r\n    return () => {\r\n      if (recognition.current !== null) {\r\n        recognition.current.stop()\r\n      }\r\n    }\r\n  }, [SpeechRecognition, editor, isEnabled, report])\r\n  useEffect(() => {\r\n    return editor.registerCommand(\r\n      SPEECH_TO_TEXT_COMMAND,\r\n      (_isEnabled: boolean) => {\r\n        setIsEnabled(_isEnabled)\r\n        return true\r\n      },\r\n      COMMAND_PRIORITY_EDITOR\r\n    )\r\n  }, [editor])\r\n\r\n  return (\r\n    <Tooltip>\r\n      <TooltipTrigger asChild>\r\n        <Button\r\n          onClick={() => {\r\n            editor.dispatchCommand(SPEECH_TO_TEXT_COMMAND, !isSpeechToText)\r\n            setIsSpeechToText(!isSpeechToText)\r\n          }}\r\n          variant={isSpeechToText ? 'secondary' : 'ghost'}\r\n          title=\"Speech To Text\"\r\n          aria-label={`${isSpeechToText ? 'Enable' : 'Disable'} speech to text`}\r\n          className=\"p-2\"\r\n          size={'sm'}\r\n        >\r\n          <MicIcon className=\"size-4\" />\r\n        </Button>\r\n      </TooltipTrigger>\r\n      <TooltipContent>Speech To Text</TooltipContent>\r\n    </Tooltip>\r\n  )\r\n}\r\n\r\nexport const SpeechToTextPlugin = SUPPORT_SPEECH_RECOGNITION\r\n  ? SpeechToTextPluginImpl\r\n  : () => null;",
      "type": "registry:component",
      "target": "components/editor/plugins/actions/speech-to-text-plugin.tsx"
    },
    {
      "path": "editor/editor-hooks/use-report.ts",
      "content": "import { useCallback, useEffect, useRef } from 'react'\r\n\r\nconst getElement = (): HTMLElement => {\r\n  let element = document.getElementById('report-container')\r\n\r\n  if (element === null) {\r\n    element = document.createElement('div')\r\n    element.id = 'report-container'\r\n    element.style.position = 'fixed'\r\n    element.style.top = '50%'\r\n    element.style.left = '50%'\r\n    element.style.fontSize = '32px'\r\n    element.style.transform = 'translate(-50%, -50px)'\r\n    element.style.padding = '20px'\r\n    element.style.background = 'rgba(240, 240, 240, 0.4)'\r\n    element.style.borderRadius = '20px'\r\n\r\n    if (document.body) {\r\n      document.body.appendChild(element)\r\n    }\r\n  }\r\n\r\n  return element\r\n}\r\n\r\nexport function useReport(): (arg0: string) => ReturnType<typeof setTimeout> {\r\n  const timer = useRef<ReturnType<typeof setTimeout> | null>(null)\r\n  const cleanup = useCallback(() => {\r\n    if (timer.current !== null) {\r\n      clearTimeout(timer.current)\r\n      timer.current = null\r\n    }\r\n\r\n    if (document.body) {\r\n      document.body.removeChild(getElement())\r\n    }\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    return cleanup\r\n  }, [cleanup])\r\n\r\n  return useCallback(\r\n    (content) => {\r\n      console.log(content)\r\n      const element = getElement()\r\n      if (timer.current !== null) {\r\n        clearTimeout(timer.current)\r\n      }\r\n      element.innerHTML = content\r\n      timer.current = setTimeout(cleanup, 1000)\r\n      return timer.current\r\n    },\r\n    [cleanup]\r\n  )\r\n}\r\n",
      "type": "registry:hook",
      "target": "components/editor/editor-hooks/use-report.ts"
    },
    {
      "path": "editor/shared/can-use-dom.ts",
      "content": "export const CAN_USE_DOM: boolean =\r\n  typeof window !== 'undefined' &&\r\n  typeof window.document !== 'undefined' &&\r\n  typeof window.document.createElement !== 'undefined'\r\n",
      "type": "registry:component",
      "target": "components/editor/shared/can-use-dom.ts"
    }
  ]
}