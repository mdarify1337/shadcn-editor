{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-plugin",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "dependencies": [
    "@lexical/utils",
    "@lexical/markdown"
  ],
  "registryDependencies": [
    "button",
    "dialog",
    "input",
    "label",
    "select",
    "tabs",
    "https://shadcn-editor.vercel.app/r/toolbar-plugin.json"
  ],
  "files": [
    {
      "path": "editor/plugins/images-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useEffect, useRef, useState, JSX } from 'react'\r\nimport * as React from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport { $wrapNodeInElement, mergeRegister } from '@lexical/utils'\r\nimport {\r\n  $createParagraphNode,\r\n  $createRangeSelection,\r\n  $getSelection,\r\n  $insertNodes,\r\n  $isNodeSelection,\r\n  $isRootOrShadowRoot,\r\n  $setSelection,\r\n  COMMAND_PRIORITY_EDITOR,\r\n  COMMAND_PRIORITY_HIGH,\r\n  COMMAND_PRIORITY_LOW,\r\n  DRAGOVER_COMMAND,\r\n  DRAGSTART_COMMAND,\r\n  DROP_COMMAND,\r\n  LexicalCommand,\r\n  LexicalEditor,\r\n  createCommand,\r\n} from 'lexical'\r\n\r\nimport { Button } from '@/registry/default/ui/button'\r\nimport { DialogFooter } from '@/registry/default/ui/dialog'\r\nimport { Input } from '@/registry/default/ui/input'\r\nimport { Label } from '@/registry/default/ui/label'\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/registry/default/ui/tabs'\r\n\r\nimport {\r\n  $createImageNode,\r\n  $isImageNode,\r\n  ImageNode,\r\n  ImagePayload,\r\n} from '@/registry/default/editor/nodes/image-node'\r\nimport { CAN_USE_DOM } from '@/registry/default/editor/shared/can-use-dom'\r\n\r\nexport type InsertImagePayload = Readonly<ImagePayload>\r\n\r\nconst getDOMSelection = (targetWindow: Window | null): Selection | null =>\r\n  CAN_USE_DOM ? (targetWindow || window).getSelection() : null\r\n\r\nexport const INSERT_IMAGE_COMMAND: LexicalCommand<InsertImagePayload> =\r\n  createCommand('INSERT_IMAGE_COMMAND')\r\n\r\nexport function InsertImageUriDialogBody({\r\n  onClick,\r\n}: {\r\n  onClick: (payload: InsertImagePayload) => void\r\n}) {\r\n  const [src, setSrc] = useState('')\r\n  const [altText, setAltText] = useState('')\r\n\r\n  const isDisabled = src === ''\r\n\r\n  return (\r\n    <div className=\"grid gap-4 py-4\">\r\n      <div className=\"grid gap-2\">\r\n        <Label htmlFor=\"image-url\">Image URL</Label>\r\n        <Input\r\n          id=\"image-url\"\r\n          placeholder=\"i.e. https://source.unsplash.com/random\"\r\n          onChange={(e) => setSrc(e.target.value)}\r\n          value={src}\r\n          data-test-id=\"image-modal-url-input\"\r\n        />\r\n      </div>\r\n      <div className=\"grid gap-2\">\r\n        <Label htmlFor=\"alt-text\">Alt Text</Label>\r\n        <Input\r\n          id=\"alt-text\"\r\n          placeholder=\"Random unsplash image\"\r\n          onChange={(e) => setAltText(e.target.value)}\r\n          value={altText}\r\n          data-test-id=\"image-modal-alt-text-input\"\r\n        />\r\n      </div>\r\n      <DialogFooter>\r\n        <Button\r\n          type=\"submit\"\r\n          disabled={isDisabled}\r\n          onClick={() => onClick({ altText, src })}\r\n          data-test-id=\"image-modal-confirm-btn\"\r\n        >\r\n          Confirm\r\n        </Button>\r\n      </DialogFooter>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function InsertImageUploadedDialogBody({\r\n  onClick,\r\n}: {\r\n  onClick: (payload: InsertImagePayload) => void\r\n}) {\r\n  const [src, setSrc] = useState('')\r\n  const [altText, setAltText] = useState('')\r\n\r\n  const isDisabled = src === ''\r\n\r\n  const loadImage = (files: FileList | null) => {\r\n    const reader = new FileReader()\r\n    reader.onload = function () {\r\n      if (typeof reader.result === 'string') {\r\n        setSrc(reader.result)\r\n      }\r\n      return ''\r\n    }\r\n    if (files !== null) {\r\n      reader.readAsDataURL(files[0])\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"grid gap-4 py-4\">\r\n      <div className=\"grid gap-2\">\r\n        <Label htmlFor=\"image-upload\">Image Upload</Label>\r\n        <Input\r\n          id=\"image-upload\"\r\n          type=\"file\"\r\n          onChange={(e) => loadImage(e.target.files)}\r\n          accept=\"image/*\"\r\n          data-test-id=\"image-modal-file-upload\"\r\n        />\r\n      </div>\r\n      <div className=\"grid gap-2\">\r\n        <Label htmlFor=\"alt-text\">Alt Text</Label>\r\n        <Input\r\n          id=\"alt-text\"\r\n          placeholder=\"Descriptive alternative text\"\r\n          onChange={(e) => setAltText(e.target.value)}\r\n          value={altText}\r\n          data-test-id=\"image-modal-alt-text-input\"\r\n        />\r\n      </div>\r\n      <Button\r\n        type=\"submit\"\r\n        disabled={isDisabled}\r\n        onClick={() => onClick({ altText, src })}\r\n        data-test-id=\"image-modal-file-upload-btn\"\r\n      >\r\n        Confirm\r\n      </Button>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function InsertImageDialog({\r\n  activeEditor,\r\n  onClose,\r\n}: {\r\n  activeEditor: LexicalEditor\r\n  onClose: () => void\r\n}): JSX.Element {\r\n  const hasModifier = useRef(false)\r\n\r\n  useEffect(() => {\r\n    hasModifier.current = false\r\n    const handler = (e: KeyboardEvent) => {\r\n      hasModifier.current = e.altKey\r\n    }\r\n    document.addEventListener('keydown', handler)\r\n    return () => {\r\n      document.removeEventListener('keydown', handler)\r\n    }\r\n  }, [activeEditor])\r\n\r\n  const onClick = (payload: InsertImagePayload) => {\r\n    activeEditor.dispatchCommand(INSERT_IMAGE_COMMAND, payload)\r\n    onClose()\r\n  }\r\n\r\n  return (\r\n    <Tabs defaultValue=\"url\">\r\n      <TabsList className=\"w-full\">\r\n        <TabsTrigger value=\"url\" className=\"w-full\">\r\n          URL\r\n        </TabsTrigger>\r\n        <TabsTrigger value=\"file\" className=\"w-full\">\r\n          File\r\n        </TabsTrigger>\r\n      </TabsList>\r\n      <TabsContent value=\"url\">\r\n        <InsertImageUriDialogBody onClick={onClick} />\r\n      </TabsContent>\r\n      <TabsContent value=\"file\">\r\n        <InsertImageUploadedDialogBody onClick={onClick} />\r\n      </TabsContent>\r\n    </Tabs>\r\n  )\r\n}\r\n\r\nexport function ImagesPlugin({\r\n  captionsEnabled,\r\n}: {\r\n  captionsEnabled?: boolean\r\n}): JSX.Element | null {\r\n  const [editor] = useLexicalComposerContext()\r\n\r\n  useEffect(() => {\r\n    if (!editor.hasNodes([ImageNode])) {\r\n      throw new Error('ImagesPlugin: ImageNode not registered on editor')\r\n    }\r\n\r\n    return mergeRegister(\r\n      editor.registerCommand<InsertImagePayload>(\r\n        INSERT_IMAGE_COMMAND,\r\n        (payload) => {\r\n          const imageNode = $createImageNode(payload)\r\n          $insertNodes([imageNode])\r\n          if ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {\r\n            $wrapNodeInElement(imageNode, $createParagraphNode).selectEnd()\r\n          }\r\n\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_EDITOR\r\n      ),\r\n      editor.registerCommand<DragEvent>(\r\n        DRAGSTART_COMMAND,\r\n        (event) => {\r\n          return $onDragStart(event)\r\n        },\r\n        COMMAND_PRIORITY_HIGH\r\n      ),\r\n      editor.registerCommand<DragEvent>(\r\n        DRAGOVER_COMMAND,\r\n        (event) => {\r\n          return $onDragover(event)\r\n        },\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand<DragEvent>(\r\n        DROP_COMMAND,\r\n        (event) => {\r\n          return $onDrop(event, editor)\r\n        },\r\n        COMMAND_PRIORITY_HIGH\r\n      )\r\n    )\r\n  }, [captionsEnabled, editor])\r\n\r\n  return null\r\n}\r\n\r\nfunction $onDragStart(event: DragEvent): boolean {\r\n  const node = $getImageNodeInSelection()\r\n  if (!node) {\r\n    return false\r\n  }\r\n  const dataTransfer = event.dataTransfer\r\n  if (!dataTransfer) {\r\n    return false\r\n  }\r\n  const TRANSPARENT_IMAGE =\r\n    'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\r\n  const img = document.createElement('img')\r\n  img.src = TRANSPARENT_IMAGE\r\n  dataTransfer.setData('text/plain', '_')\r\n  dataTransfer.setDragImage(img, 0, 0)\r\n  dataTransfer.setData(\r\n    'application/x-lexical-drag',\r\n    JSON.stringify({\r\n      data: {\r\n        altText: node.__altText,\r\n        caption: node.__caption,\r\n        height: node.__height,\r\n        key: node.getKey(),\r\n        maxWidth: node.__maxWidth,\r\n        showCaption: node.__showCaption,\r\n        src: node.__src,\r\n        width: node.__width,\r\n      },\r\n      type: 'image',\r\n    })\r\n  )\r\n\r\n  return true\r\n}\r\n\r\nfunction $onDragover(event: DragEvent): boolean {\r\n  const node = $getImageNodeInSelection()\r\n  if (!node) {\r\n    return false\r\n  }\r\n  if (!canDropImage(event)) {\r\n    event.preventDefault()\r\n  }\r\n  return true\r\n}\r\n\r\nfunction $onDrop(event: DragEvent, editor: LexicalEditor): boolean {\r\n  const node = $getImageNodeInSelection()\r\n  if (!node) {\r\n    return false\r\n  }\r\n  const data = getDragImageData(event)\r\n  if (!data) {\r\n    return false\r\n  }\r\n  event.preventDefault()\r\n  if (canDropImage(event)) {\r\n    const range = getDragSelection(event)\r\n    node.remove()\r\n    const rangeSelection = $createRangeSelection()\r\n    if (range !== null && range !== undefined) {\r\n      rangeSelection.applyDOMRange(range)\r\n    }\r\n    $setSelection(rangeSelection)\r\n    editor.dispatchCommand(INSERT_IMAGE_COMMAND, data)\r\n  }\r\n  return true\r\n}\r\n\r\nfunction $getImageNodeInSelection(): ImageNode | null {\r\n  const selection = $getSelection()\r\n  if (!$isNodeSelection(selection)) {\r\n    return null\r\n  }\r\n  const nodes = selection.getNodes()\r\n  const node = nodes[0]\r\n  return $isImageNode(node) ? node : null\r\n}\r\n\r\nfunction getDragImageData(event: DragEvent): null | InsertImagePayload {\r\n  const dragData = event.dataTransfer?.getData('application/x-lexical-drag')\r\n  if (!dragData) {\r\n    return null\r\n  }\r\n  const { type, data } = JSON.parse(dragData)\r\n  if (type !== 'image') {\r\n    return null\r\n  }\r\n\r\n  return data\r\n}\r\n\r\ndeclare global {\r\n  interface DragEvent {\r\n    rangeOffset?: number\r\n    rangeParent?: Node\r\n  }\r\n}\r\n\r\nfunction canDropImage(event: DragEvent): boolean {\r\n  const target = event.target\r\n  return !!(\r\n    target &&\r\n    target instanceof HTMLElement &&\r\n    !target.closest('code, span.editor-image') &&\r\n    target.parentElement &&\r\n    target.parentElement.closest('div.ContentEditable__root')\r\n  )\r\n}\r\n\r\nfunction getDragSelection(event: DragEvent): Range | null | undefined {\r\n  let range\r\n  const target = event.target as null | Element | Document\r\n  const targetWindow =\r\n    target == null\r\n      ? null\r\n      : target.nodeType === 9\r\n        ? (target as Document).defaultView\r\n        : (target as Element).ownerDocument.defaultView\r\n  const domSelection = getDOMSelection(targetWindow)\r\n  if (document.caretRangeFromPoint) {\r\n    range = document.caretRangeFromPoint(event.clientX, event.clientY)\r\n  } else if (event.rangeParent && domSelection !== null) {\r\n    domSelection.collapse(event.rangeParent, event.rangeOffset || 0)\r\n    range = domSelection.getRangeAt(0)\r\n  } else {\r\n    throw Error(`Cannot get the selection when dragging`)\r\n  }\r\n\r\n  return range\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/images-plugin.tsx"
    },
    {
      "path": "editor/nodes/image-node.tsx",
      "content": "import * as React from 'react'\r\nimport { Suspense, JSX } from 'react'\r\n\r\nimport type {\r\n  DOMConversionMap,\r\n  DOMConversionOutput,\r\n  DOMExportOutput,\r\n  EditorConfig,\r\n  LexicalEditor,\r\n  LexicalNode,\r\n  NodeKey,\r\n  SerializedEditor,\r\n  SerializedLexicalNode,\r\n  Spread,\r\n} from 'lexical'\r\nimport { $applyNodeReplacement, DecoratorNode, createEditor } from 'lexical'\r\n\r\nconst ImageComponent = React.lazy(() => import('../editor-ui/image-component'))\r\n\r\nexport interface ImagePayload {\r\n  altText: string\r\n  caption?: LexicalEditor\r\n  height?: number\r\n  key?: NodeKey\r\n  maxWidth?: number\r\n  showCaption?: boolean\r\n  src: string\r\n  width?: number\r\n  captionsEnabled?: boolean\r\n}\r\n\r\nfunction isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\r\n  return (\r\n    img.parentElement != null &&\r\n    img.parentElement.tagName === 'LI' &&\r\n    img.previousSibling === null &&\r\n    img.getAttribute('aria-roledescription') === 'checkbox'\r\n  )\r\n}\r\n\r\nfunction $convertImageElement(domNode: Node): null | DOMConversionOutput {\r\n  const img = domNode as HTMLImageElement\r\n  if (img.src.startsWith('file:///') || isGoogleDocCheckboxImg(img)) {\r\n    return null\r\n  }\r\n  const { alt: altText, src, width, height } = img\r\n  const node = $createImageNode({ altText, height, src, width })\r\n  return { node }\r\n}\r\n\r\nexport type SerializedImageNode = Spread<\r\n  {\r\n    altText: string\r\n    caption: SerializedEditor\r\n    height?: number\r\n    maxWidth: number\r\n    showCaption: boolean\r\n    src: string\r\n    width?: number\r\n  },\r\n  SerializedLexicalNode\r\n>\r\n\r\nexport class ImageNode extends DecoratorNode<JSX.Element> {\r\n  __src: string\r\n  __altText: string\r\n  __width: 'inherit' | number\r\n  __height: 'inherit' | number\r\n  __maxWidth: number\r\n  __showCaption: boolean\r\n  __caption: LexicalEditor\r\n  // Captions cannot yet be used within editor cells\r\n  __captionsEnabled: boolean\r\n\r\n  static getType(): string {\r\n    return 'image'\r\n  }\r\n\r\n  static clone(node: ImageNode): ImageNode {\r\n    return new ImageNode(\r\n      node.__src,\r\n      node.__altText,\r\n      node.__maxWidth,\r\n      node.__width,\r\n      node.__height,\r\n      node.__showCaption,\r\n      node.__caption,\r\n      node.__captionsEnabled,\r\n      node.__key\r\n    )\r\n  }\r\n\r\n  static importJSON(serializedNode: SerializedImageNode): ImageNode {\r\n    const { altText, height, width, maxWidth, caption, src, showCaption } =\r\n      serializedNode\r\n    const node = $createImageNode({\r\n      altText,\r\n      height,\r\n      maxWidth,\r\n      showCaption,\r\n      src,\r\n      width,\r\n    })\r\n    const nestedEditor = node.__caption\r\n    const editorState = nestedEditor.parseEditorState(caption.editorState)\r\n    if (!editorState.isEmpty()) {\r\n      nestedEditor.setEditorState(editorState)\r\n    }\r\n    return node\r\n  }\r\n\r\n  exportDOM(): DOMExportOutput {\r\n    const element = document.createElement('img')\r\n    element.setAttribute('src', this.__src)\r\n    element.setAttribute('alt', this.__altText)\r\n    element.setAttribute('width', this.__width.toString())\r\n    element.setAttribute('height', this.__height.toString())\r\n    return { element }\r\n  }\r\n\r\n  static importDOM(): DOMConversionMap | null {\r\n    return {\r\n      img: (node: Node) => ({\r\n        conversion: $convertImageElement,\r\n        priority: 0,\r\n      }),\r\n    }\r\n  }\r\n\r\n  constructor(\r\n    src: string,\r\n    altText: string,\r\n    maxWidth: number,\r\n    width?: 'inherit' | number,\r\n    height?: 'inherit' | number,\r\n    showCaption?: boolean,\r\n    caption?: LexicalEditor,\r\n    captionsEnabled?: boolean,\r\n    key?: NodeKey\r\n  ) {\r\n    super(key)\r\n    this.__src = src\r\n    this.__altText = altText\r\n    this.__maxWidth = maxWidth\r\n    this.__width = width || 'inherit'\r\n    this.__height = height || 'inherit'\r\n    this.__showCaption = showCaption || false\r\n    this.__caption =\r\n      caption ||\r\n      createEditor({\r\n        nodes: [],\r\n      })\r\n    this.__captionsEnabled = captionsEnabled || captionsEnabled === undefined\r\n  }\r\n\r\n  exportJSON(): SerializedImageNode {\r\n    return {\r\n      altText: this.getAltText(),\r\n      caption: this.__caption.toJSON(),\r\n      height: this.__height === 'inherit' ? 0 : this.__height,\r\n      maxWidth: this.__maxWidth,\r\n      showCaption: this.__showCaption,\r\n      src: this.getSrc(),\r\n      type: 'image',\r\n      version: 1,\r\n      width: this.__width === 'inherit' ? 0 : this.__width,\r\n    }\r\n  }\r\n\r\n  setWidthAndHeight(\r\n    width: 'inherit' | number,\r\n    height: 'inherit' | number\r\n  ): void {\r\n    const writable = this.getWritable()\r\n    writable.__width = width\r\n    writable.__height = height\r\n  }\r\n\r\n  setShowCaption(showCaption: boolean): void {\r\n    const writable = this.getWritable()\r\n    writable.__showCaption = showCaption\r\n  }\r\n\r\n  // View\r\n\r\n  createDOM(config: EditorConfig): HTMLElement {\r\n    const span = document.createElement('span')\r\n    const theme = config.theme\r\n    const className = theme.image\r\n    if (className !== undefined) {\r\n      span.className = className\r\n    }\r\n    return span\r\n  }\r\n\r\n  updateDOM(): false {\r\n    return false\r\n  }\r\n\r\n  getSrc(): string {\r\n    return this.__src\r\n  }\r\n\r\n  getAltText(): string {\r\n    return this.__altText\r\n  }\r\n\r\n  decorate(): JSX.Element {\r\n    return (\r\n      <Suspense fallback={null}>\r\n        <ImageComponent\r\n          src={this.__src}\r\n          altText={this.__altText}\r\n          width={this.__width}\r\n          height={this.__height}\r\n          maxWidth={this.__maxWidth}\r\n          nodeKey={this.getKey()}\r\n          showCaption={this.__showCaption}\r\n          caption={this.__caption}\r\n          captionsEnabled={this.__captionsEnabled}\r\n          resizable={true}\r\n        />\r\n      </Suspense>\r\n    )\r\n  }\r\n}\r\n\r\nexport function $createImageNode({\r\n  altText,\r\n  height,\r\n  maxWidth = 500,\r\n  captionsEnabled,\r\n  src,\r\n  width,\r\n  showCaption,\r\n  caption,\r\n  key,\r\n}: ImagePayload): ImageNode {\r\n  return $applyNodeReplacement(\r\n    new ImageNode(\r\n      src,\r\n      altText,\r\n      maxWidth,\r\n      width,\r\n      height,\r\n      showCaption,\r\n      caption,\r\n      captionsEnabled,\r\n      key\r\n    )\r\n  )\r\n}\r\n\r\nexport function $isImageNode(\r\n  node: LexicalNode | null | undefined\r\n): node is ImageNode {\r\n  return node instanceof ImageNode\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/nodes/image-node.tsx"
    },
    {
      "path": "editor/editor-ui/image-component.tsx",
      "content": "import * as React from 'react'\r\nimport { Suspense, useCallback, useEffect, useRef, useState, JSX } from 'react'\r\n\r\nimport { AutoFocusPlugin } from '@lexical/react/LexicalAutoFocusPlugin'\r\nimport { useCollaborationContext } from '@lexical/react/LexicalCollaborationContext'\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport { LexicalErrorBoundary } from '@lexical/react/LexicalErrorBoundary'\r\nimport { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin'\r\nimport { LexicalNestedComposer } from '@lexical/react/LexicalNestedComposer'\r\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin'\r\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\r\nimport { useLexicalNodeSelection } from '@lexical/react/useLexicalNodeSelection'\r\nimport { mergeRegister } from '@lexical/utils'\r\nimport type {\r\n  BaseSelection,\r\n  LexicalCommand,\r\n  LexicalEditor,\r\n  NodeKey,\r\n} from 'lexical'\r\nimport {\r\n  $getNodeByKey,\r\n  $getSelection,\r\n  $isNodeSelection,\r\n  $isRangeSelection,\r\n  $setSelection,\r\n  CLICK_COMMAND,\r\n  COMMAND_PRIORITY_LOW,\r\n  DRAGSTART_COMMAND,\r\n  KEY_BACKSPACE_COMMAND,\r\n  KEY_DELETE_COMMAND,\r\n  KEY_ENTER_COMMAND,\r\n  KEY_ESCAPE_COMMAND,\r\n  ParagraphNode,\r\n  RootNode,\r\n  SELECTION_CHANGE_COMMAND,\r\n  TextNode,\r\n  createCommand,\r\n} from 'lexical'\r\n\r\nimport { $isImageNode } from '@/registry/default/editor/nodes/image-node'\r\n// import brokenImage from '@/registry/default/editor/images/image-broken.svg';\r\nimport { ContentEditable } from '@/registry/default/editor/editor-ui/content-editable'\r\nimport { ImageResizer } from '@/registry/default/editor/editor-ui/image-resizer'\r\n\r\nconst imageCache = new Set()\r\n\r\nexport const RIGHT_CLICK_IMAGE_COMMAND: LexicalCommand<MouseEvent> =\r\n  createCommand('RIGHT_CLICK_IMAGE_COMMAND')\r\n\r\nfunction useSuspenseImage(src: string) {\r\n  if (!imageCache.has(src)) {\r\n    throw new Promise((resolve) => {\r\n      const img = new Image()\r\n      img.src = src\r\n      img.onload = () => {\r\n        imageCache.add(src)\r\n        resolve(null)\r\n      }\r\n      img.onerror = () => {\r\n        imageCache.add(src)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction LazyImage({\r\n  altText,\r\n  className,\r\n  imageRef,\r\n  src,\r\n  width,\r\n  height,\r\n  maxWidth,\r\n  onError,\r\n}: {\r\n  altText: string\r\n  className: string | null\r\n  height: 'inherit' | number\r\n  imageRef: { current: null | HTMLImageElement }\r\n  maxWidth: number\r\n  src: string\r\n  width: 'inherit' | number\r\n  onError: () => void\r\n}): JSX.Element {\r\n  useSuspenseImage(src)\r\n  return (\r\n    <img\r\n      className={className || undefined}\r\n      src={src}\r\n      alt={altText}\r\n      ref={imageRef}\r\n      style={{\r\n        height,\r\n        maxWidth,\r\n        width,\r\n      }}\r\n      onError={onError}\r\n      draggable=\"false\"\r\n    />\r\n  )\r\n}\r\n\r\nfunction BrokenImage(): JSX.Element {\r\n  return (\r\n    <img\r\n      src={''}\r\n      style={{\r\n        height: 200,\r\n        opacity: 0.2,\r\n        width: 200,\r\n      }}\r\n      draggable=\"false\"\r\n    />\r\n  )\r\n}\r\n\r\nexport default function ImageComponent({\r\n  src,\r\n  altText,\r\n  nodeKey,\r\n  width,\r\n  height,\r\n  maxWidth,\r\n  resizable,\r\n  showCaption,\r\n  caption,\r\n  captionsEnabled,\r\n}: {\r\n  altText: string\r\n  caption: LexicalEditor\r\n  height: 'inherit' | number\r\n  maxWidth: number\r\n  nodeKey: NodeKey\r\n  resizable: boolean\r\n  showCaption: boolean\r\n  src: string\r\n  width: 'inherit' | number\r\n  captionsEnabled: boolean\r\n}): JSX.Element {\r\n  const imageRef = useRef<null | HTMLImageElement>(null)\r\n  const buttonRef = useRef<HTMLButtonElement | null>(null)\r\n  const [isSelected, setSelected, clearSelection] =\r\n    useLexicalNodeSelection(nodeKey)\r\n  const [isResizing, setIsResizing] = useState<boolean>(false)\r\n  const { isCollabActive } = useCollaborationContext()\r\n  const [editor] = useLexicalComposerContext()\r\n  const [selection, setSelection] = useState<BaseSelection | null>(null)\r\n  const activeEditorRef = useRef<LexicalEditor | null>(null)\r\n  const [isLoadError, setIsLoadError] = useState<boolean>(false)\r\n  const isEditable = useLexicalEditable()\r\n\r\n  const $onDelete = useCallback(\r\n    (payload: KeyboardEvent) => {\r\n      const deleteSelection = $getSelection()\r\n      if (isSelected && $isNodeSelection(deleteSelection)) {\r\n        const event: KeyboardEvent = payload\r\n        event.preventDefault()\r\n        editor.update(() => {\r\n          deleteSelection.getNodes().forEach((node) => {\r\n            if ($isImageNode(node)) {\r\n              node.remove()\r\n            }\r\n          })\r\n        })\r\n      }\r\n      return false\r\n    },\r\n    [editor, isSelected]\r\n  )\r\n\r\n  const $onEnter = useCallback(\r\n    (event: KeyboardEvent) => {\r\n      const latestSelection = $getSelection()\r\n      const buttonElem = buttonRef.current\r\n      if (\r\n        isSelected &&\r\n        $isNodeSelection(latestSelection) &&\r\n        latestSelection.getNodes().length === 1\r\n      ) {\r\n        if (showCaption) {\r\n          // Move focus into nested editor\r\n          $setSelection(null)\r\n          event.preventDefault()\r\n          caption.focus()\r\n          return true\r\n        } else if (\r\n          buttonElem !== null &&\r\n          buttonElem !== document.activeElement\r\n        ) {\r\n          event.preventDefault()\r\n          buttonElem.focus()\r\n          return true\r\n        }\r\n      }\r\n      return false\r\n    },\r\n    [caption, isSelected, showCaption]\r\n  )\r\n\r\n  const $onEscape = useCallback(\r\n    (event: KeyboardEvent) => {\r\n      if (\r\n        activeEditorRef.current === caption ||\r\n        buttonRef.current === event.target\r\n      ) {\r\n        $setSelection(null)\r\n        editor.update(() => {\r\n          setSelected(true)\r\n          const parentRootElement = editor.getRootElement()\r\n          if (parentRootElement !== null) {\r\n            parentRootElement.focus()\r\n          }\r\n        })\r\n        return true\r\n      }\r\n      return false\r\n    },\r\n    [caption, editor, setSelected]\r\n  )\r\n\r\n  const onClick = useCallback(\r\n    (payload: MouseEvent) => {\r\n      const event = payload\r\n\r\n      if (isResizing) {\r\n        return true\r\n      }\r\n      if (event.target === imageRef.current) {\r\n        if (event.shiftKey) {\r\n          setSelected(!isSelected)\r\n        } else {\r\n          clearSelection()\r\n          setSelected(true)\r\n        }\r\n        return true\r\n      }\r\n\r\n      return false\r\n    },\r\n    [isResizing, isSelected, setSelected, clearSelection]\r\n  )\r\n\r\n  const onRightClick = useCallback(\r\n    (event: MouseEvent): void => {\r\n      editor.getEditorState().read(() => {\r\n        const latestSelection = $getSelection()\r\n        const domElement = event.target as HTMLElement\r\n        if (\r\n          domElement.tagName === 'IMG' &&\r\n          $isRangeSelection(latestSelection) &&\r\n          latestSelection.getNodes().length === 1\r\n        ) {\r\n          editor.dispatchCommand(RIGHT_CLICK_IMAGE_COMMAND, event as MouseEvent)\r\n        }\r\n      })\r\n    },\r\n    [editor]\r\n  )\r\n\r\n  useEffect(() => {\r\n    let isMounted = true\r\n    const rootElement = editor.getRootElement()\r\n    const unregister = mergeRegister(\r\n      editor.registerUpdateListener(({ editorState }) => {\r\n        if (isMounted) {\r\n          setSelection(editorState.read(() => $getSelection()))\r\n        }\r\n      }),\r\n      editor.registerCommand(\r\n        SELECTION_CHANGE_COMMAND,\r\n        (_, activeEditor) => {\r\n          activeEditorRef.current = activeEditor\r\n          return false\r\n        },\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand<MouseEvent>(\r\n        CLICK_COMMAND,\r\n        onClick,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand<MouseEvent>(\r\n        RIGHT_CLICK_IMAGE_COMMAND,\r\n        onClick,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        DRAGSTART_COMMAND,\r\n        (event) => {\r\n          if (event.target === imageRef.current) {\r\n            // TODO This is just a temporary workaround for FF to behave like other browsers.\r\n            // Ideally, this handles drag & drop too (and all browsers).\r\n            event.preventDefault()\r\n            return true\r\n          }\r\n          return false\r\n        },\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        KEY_DELETE_COMMAND,\r\n        $onDelete,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        KEY_BACKSPACE_COMMAND,\r\n        $onDelete,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(KEY_ENTER_COMMAND, $onEnter, COMMAND_PRIORITY_LOW),\r\n      editor.registerCommand(\r\n        KEY_ESCAPE_COMMAND,\r\n        $onEscape,\r\n        COMMAND_PRIORITY_LOW\r\n      )\r\n    )\r\n\r\n    rootElement?.addEventListener('contextmenu', onRightClick)\r\n\r\n    return () => {\r\n      isMounted = false\r\n      unregister()\r\n      rootElement?.removeEventListener('contextmenu', onRightClick)\r\n    }\r\n  }, [\r\n    clearSelection,\r\n    editor,\r\n    isResizing,\r\n    isSelected,\r\n    nodeKey,\r\n    $onDelete,\r\n    $onEnter,\r\n    $onEscape,\r\n    onClick,\r\n    onRightClick,\r\n    setSelected,\r\n  ])\r\n\r\n  const setShowCaption = () => {\r\n    editor.update(() => {\r\n      const node = $getNodeByKey(nodeKey)\r\n      if ($isImageNode(node)) {\r\n        node.setShowCaption(true)\r\n      }\r\n    })\r\n  }\r\n\r\n  const onResizeEnd = (\r\n    nextWidth: 'inherit' | number,\r\n    nextHeight: 'inherit' | number\r\n  ) => {\r\n    // Delay hiding the resize bars for click case\r\n    setTimeout(() => {\r\n      setIsResizing(false)\r\n    }, 200)\r\n\r\n    editor.update(() => {\r\n      const node = $getNodeByKey(nodeKey)\r\n      if ($isImageNode(node)) {\r\n        node.setWidthAndHeight(nextWidth, nextHeight)\r\n      }\r\n    })\r\n  }\r\n\r\n  const onResizeStart = () => {\r\n    setIsResizing(true)\r\n  }\r\n\r\n  const draggable = isSelected && $isNodeSelection(selection) && !isResizing\r\n  const isFocused = (isSelected || isResizing) && isEditable\r\n  return (\r\n    <Suspense fallback={null}>\r\n      <>\r\n        <div draggable={draggable}>\r\n          {isLoadError ? (\r\n            <BrokenImage />\r\n          ) : (\r\n            <LazyImage\r\n              className={`max-w-full cursor-default ${\r\n                isFocused\r\n                  ? `${$isNodeSelection(selection) ? 'draggable cursor-grab active:cursor-grabbing' : ''} focused ring-2 ring-primary ring-offset-2`\r\n                  : null\r\n              }`}\r\n              src={src}\r\n              altText={altText}\r\n              imageRef={imageRef}\r\n              width={width}\r\n              height={height}\r\n              maxWidth={maxWidth}\r\n              onError={() => setIsLoadError(true)}\r\n            />\r\n          )}\r\n        </div>\r\n\r\n        {showCaption && (\r\n          <div className=\"image-caption-container absolute bottom-1 left-0 right-0 m-0 block min-w-[100px] overflow-hidden border-t bg-white/90 p-0\">\r\n            <LexicalNestedComposer\r\n              initialEditor={caption}\r\n              initialNodes={[\r\n                RootNode,\r\n                TextNode,\r\n                ParagraphNode,\r\n              ]}\r\n            >\r\n              <AutoFocusPlugin />\r\n              <HistoryPlugin />\r\n              <RichTextPlugin\r\n                contentEditable={\r\n                  <ContentEditable\r\n                    className=\"ImageNode__contentEditable user-select-text word-break-break-word relative block min-h-5 w-[calc(100%-20px)] cursor-text resize-none whitespace-pre-wrap border-0 p-2.5 text-sm caret-primary outline-none\"\r\n                    placeholderClassName=\"ImageNode__placeholder text-sm text-muted-foreground overflow-hidden absolute top-2.5 left-2.5 pointer-events-none text-ellipsis user-select-none whitespace-nowrap inline-block\"\r\n                    placeholder=\"Enter a caption...\"\r\n                  />\r\n                }\r\n                ErrorBoundary={LexicalErrorBoundary}\r\n              />\r\n            </LexicalNestedComposer>\r\n          </div>\r\n        )}\r\n        {resizable && $isNodeSelection(selection) && isFocused && (\r\n          <ImageResizer\r\n            showCaption={showCaption}\r\n            setShowCaption={setShowCaption}\r\n            editor={editor}\r\n            buttonRef={buttonRef}\r\n            imageRef={imageRef}\r\n            maxWidth={maxWidth}\r\n            onResizeStart={onResizeStart}\r\n            onResizeEnd={onResizeEnd}\r\n            captionsEnabled={!isLoadError && captionsEnabled}\r\n          />\r\n        )}\r\n      </>\r\n    </Suspense>\r\n  )\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/editor-ui/image-component.tsx"
    },
    {
      "path": "editor/editor-ui/image-resizer.tsx",
      "content": "import * as React from 'react'\r\nimport { useRef, JSX } from 'react'\r\n\r\nimport { calculateZoomLevel } from '@lexical/utils'\r\nimport type { LexicalEditor } from 'lexical'\r\n\r\nimport { Button } from '@/registry/default/ui/button'\r\n\r\nfunction clamp(value: number, min: number, max: number) {\r\n  return Math.min(Math.max(value, min), max)\r\n}\r\n\r\nconst Direction = {\r\n  east: 1 << 0,\r\n  north: 1 << 3,\r\n  south: 1 << 1,\r\n  west: 1 << 2,\r\n}\r\n\r\nexport function ImageResizer({\r\n  onResizeStart,\r\n  onResizeEnd,\r\n  buttonRef,\r\n  imageRef,\r\n  maxWidth,\r\n  editor,\r\n  showCaption,\r\n  setShowCaption,\r\n  captionsEnabled,\r\n}: {\r\n  editor: LexicalEditor\r\n  buttonRef: { current: null | HTMLButtonElement }\r\n  imageRef: { current: null | HTMLElement }\r\n  maxWidth?: number\r\n  onResizeEnd: (width: 'inherit' | number, height: 'inherit' | number) => void\r\n  onResizeStart: () => void\r\n  setShowCaption: (show: boolean) => void\r\n  showCaption: boolean\r\n  captionsEnabled: boolean\r\n}): JSX.Element {\r\n  const controlWrapperRef = useRef<HTMLDivElement>(null)\r\n  const userSelect = useRef({\r\n    priority: '',\r\n    value: 'default',\r\n  })\r\n  const positioningRef = useRef<{\r\n    currentHeight: 'inherit' | number\r\n    currentWidth: 'inherit' | number\r\n    direction: number\r\n    isResizing: boolean\r\n    ratio: number\r\n    startHeight: number\r\n    startWidth: number\r\n    startX: number\r\n    startY: number\r\n  }>({\r\n    currentHeight: 0,\r\n    currentWidth: 0,\r\n    direction: 0,\r\n    isResizing: false,\r\n    ratio: 0,\r\n    startHeight: 0,\r\n    startWidth: 0,\r\n    startX: 0,\r\n    startY: 0,\r\n  })\r\n  const editorRootElement = editor.getRootElement()\r\n  // Find max width, accounting for editor padding.\r\n  const maxWidthContainer = maxWidth\r\n    ? maxWidth\r\n    : editorRootElement !== null\r\n      ? editorRootElement.getBoundingClientRect().width - 20\r\n      : 100\r\n  const maxHeightContainer =\r\n    editorRootElement !== null\r\n      ? editorRootElement.getBoundingClientRect().height - 20\r\n      : 100\r\n\r\n  const minWidth = 100\r\n  const minHeight = 100\r\n\r\n  const setStartCursor = (direction: number) => {\r\n    const ew = direction === Direction.east || direction === Direction.west\r\n    const ns = direction === Direction.north || direction === Direction.south\r\n    const nwse =\r\n      (direction & Direction.north && direction & Direction.west) ||\r\n      (direction & Direction.south && direction & Direction.east)\r\n\r\n    const cursorDir = ew ? 'ew' : ns ? 'ns' : nwse ? 'nwse' : 'nesw'\r\n\r\n    if (editorRootElement !== null) {\r\n      editorRootElement.style.setProperty(\r\n        'cursor',\r\n        `${cursorDir}-resize`,\r\n        'important'\r\n      )\r\n    }\r\n    if (document.body !== null) {\r\n      document.body.style.setProperty(\r\n        'cursor',\r\n        `${cursorDir}-resize`,\r\n        'important'\r\n      )\r\n      userSelect.current.value = document.body.style.getPropertyValue(\r\n        '-webkit-user-select'\r\n      )\r\n      userSelect.current.priority = document.body.style.getPropertyPriority(\r\n        '-webkit-user-select'\r\n      )\r\n      document.body.style.setProperty(\r\n        '-webkit-user-select',\r\n        `none`,\r\n        'important'\r\n      )\r\n    }\r\n  }\r\n\r\n  const setEndCursor = () => {\r\n    if (editorRootElement !== null) {\r\n      editorRootElement.style.setProperty('cursor', 'text')\r\n    }\r\n    if (document.body !== null) {\r\n      document.body.style.setProperty('cursor', 'default')\r\n      document.body.style.setProperty(\r\n        '-webkit-user-select',\r\n        userSelect.current.value,\r\n        userSelect.current.priority\r\n      )\r\n    }\r\n  }\r\n\r\n  const handlePointerDown = (\r\n    event: React.PointerEvent<HTMLDivElement>,\r\n    direction: number\r\n  ) => {\r\n    if (!editor.isEditable()) {\r\n      return\r\n    }\r\n\r\n    const image = imageRef.current\r\n    const controlWrapper = controlWrapperRef.current\r\n\r\n    if (image !== null && controlWrapper !== null) {\r\n      event.preventDefault()\r\n      const { width, height } = image.getBoundingClientRect()\r\n      const zoom = calculateZoomLevel(image)\r\n      const positioning = positioningRef.current\r\n      positioning.startWidth = width\r\n      positioning.startHeight = height\r\n      positioning.ratio = width / height\r\n      positioning.currentWidth = width\r\n      positioning.currentHeight = height\r\n      positioning.startX = event.clientX / zoom\r\n      positioning.startY = event.clientY / zoom\r\n      positioning.isResizing = true\r\n      positioning.direction = direction\r\n\r\n      setStartCursor(direction)\r\n      onResizeStart()\r\n\r\n      controlWrapper.classList.add('touch-action-none')\r\n      image.style.height = `${height}px`\r\n      image.style.width = `${width}px`\r\n\r\n      document.addEventListener('pointermove', handlePointerMove)\r\n      document.addEventListener('pointerup', handlePointerUp)\r\n    }\r\n  }\r\n  const handlePointerMove = (event: PointerEvent) => {\r\n    const image = imageRef.current\r\n    const positioning = positioningRef.current\r\n\r\n    const isHorizontal =\r\n      positioning.direction & (Direction.east | Direction.west)\r\n    const isVertical =\r\n      positioning.direction & (Direction.south | Direction.north)\r\n\r\n    if (image !== null && positioning.isResizing) {\r\n      const zoom = calculateZoomLevel(image)\r\n      // Corner cursor\r\n      if (isHorizontal && isVertical) {\r\n        let diff = Math.floor(positioning.startX - event.clientX / zoom)\r\n        diff = positioning.direction & Direction.east ? -diff : diff\r\n\r\n        const width = clamp(\r\n          positioning.startWidth + diff,\r\n          minWidth,\r\n          maxWidthContainer\r\n        )\r\n\r\n        const height = width / positioning.ratio\r\n        image.style.width = `${width}px`\r\n        image.style.height = `${height}px`\r\n        positioning.currentHeight = height\r\n        positioning.currentWidth = width\r\n      } else if (isVertical) {\r\n        let diff = Math.floor(positioning.startY - event.clientY / zoom)\r\n        diff = positioning.direction & Direction.south ? -diff : diff\r\n\r\n        const height = clamp(\r\n          positioning.startHeight + diff,\r\n          minHeight,\r\n          maxHeightContainer\r\n        )\r\n\r\n        image.style.height = `${height}px`\r\n        positioning.currentHeight = height\r\n      } else {\r\n        let diff = Math.floor(positioning.startX - event.clientX / zoom)\r\n        diff = positioning.direction & Direction.east ? -diff : diff\r\n\r\n        const width = clamp(\r\n          positioning.startWidth + diff,\r\n          minWidth,\r\n          maxWidthContainer\r\n        )\r\n\r\n        image.style.width = `${width}px`\r\n        positioning.currentWidth = width\r\n      }\r\n    }\r\n  }\r\n  const handlePointerUp = () => {\r\n    const image = imageRef.current\r\n    const positioning = positioningRef.current\r\n    const controlWrapper = controlWrapperRef.current\r\n    if (image !== null && controlWrapper !== null && positioning.isResizing) {\r\n      const width = positioning.currentWidth\r\n      const height = positioning.currentHeight\r\n      positioning.startWidth = 0\r\n      positioning.startHeight = 0\r\n      positioning.ratio = 0\r\n      positioning.startX = 0\r\n      positioning.startY = 0\r\n      positioning.currentWidth = 0\r\n      positioning.currentHeight = 0\r\n      positioning.isResizing = false\r\n\r\n      controlWrapper.classList.remove('touch-action-none')\r\n\r\n      setEndCursor()\r\n      onResizeEnd(width, height)\r\n\r\n      document.removeEventListener('pointermove', handlePointerMove)\r\n      document.removeEventListener('pointerup', handlePointerUp)\r\n    }\r\n  }\r\n  return (\r\n    <div ref={controlWrapperRef}>\r\n      {!showCaption && captionsEnabled && (\r\n        <Button\r\n          className=\"image-caption-button absolute bottom-1 left-1/2 -translate-x-1/2\"\r\n          ref={buttonRef}\r\n          variant={'outline'}\r\n          onClick={() => {\r\n            setShowCaption(!showCaption)\r\n          }}\r\n        >\r\n          Add Caption\r\n        </Button>\r\n      )}\r\n      <div\r\n        className=\"image-resizer image-resizer-n absolute -top-2.5 left-1/2 h-3 w-3 -translate-x-1/2 cursor-ns-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.north)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-ne absolute -right-2.5 -top-2.5 h-3 w-3 cursor-nesw-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.north | Direction.east)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-e absolute -right-2.5 top-1/2 h-3 w-3 -translate-y-1/2 cursor-ew-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.east)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-se absolute -bottom-2.5 -right-2.5 h-3 w-3 cursor-nwse-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.south | Direction.east)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-s absolute -bottom-2.5 left-1/2 h-3 w-3 -translate-x-1/2 cursor-ns-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.south)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-sw absolute -bottom-2.5 -left-2.5 h-3 w-3 cursor-nesw-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.south | Direction.west)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-w absolute -left-2.5 top-1/2 h-3 w-3 -translate-y-1/2 cursor-ew-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.west)\r\n        }}\r\n      />\r\n      <div\r\n        className=\"image-resizer image-resizer-nw absolute -left-2.5 -top-2.5 h-3 w-3 cursor-nwse-resize bg-primary\"\r\n        onPointerDown={(event) => {\r\n          handlePointerDown(event, Direction.north | Direction.west)\r\n        }}\r\n      />\r\n    </div>\r\n  )\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/editor-ui/image-resizer.tsx"
    },
    {
      "path": "editor/shared/can-use-dom.ts",
      "content": "export const CAN_USE_DOM: boolean =\r\n  typeof window !== 'undefined' &&\r\n  typeof window.document !== 'undefined' &&\r\n  typeof window.document.createElement !== 'undefined'\r\n",
      "type": "registry:component",
      "target": "components/editor/shared/can-use-dom.ts"
    },
    {
      "path": "editor/transformers/markdown-image-transformer.ts",
      "content": "import { TextMatchTransformer } from '@lexical/markdown'\r\n\r\nimport { $createImageNode, $isImageNode, ImageNode } from '@/registry/default/editor/nodes/image-node'\r\n\r\nexport const IMAGE: TextMatchTransformer = {\r\n  dependencies: [ImageNode],\r\n  export: (node) => {\r\n    if (!$isImageNode(node)) {\r\n      return null\r\n    }\r\n\r\n    return `![${node.getAltText()}](${node.getSrc()})`\r\n  },\r\n  importRegExp: /!(?:\\[([^[]*)\\])(?:\\(([^(]+)\\))/,\r\n  regExp: /!(?:\\[([^[]*)\\])(?:\\(([^(]+)\\))$/,\r\n  replace: (textNode, match) => {\r\n    const [, altText, src] = match\r\n    const imageNode = $createImageNode({\r\n      altText,\r\n      maxWidth: 800,\r\n      src,\r\n    })\r\n    textNode.replace(imageNode)\r\n  },\r\n  trigger: ')',\r\n  type: 'text-match',\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/transformers/markdown-image-transformer.ts"
    },
    {
      "path": "editor/plugins/toolbar/block-insert/insert-image.tsx",
      "content": "'use client'\r\n\r\nimport { ImageIcon } from 'lucide-react'\r\n\r\nimport { useToolbarContext } from '@/registry/default/editor/context/toolbar-context'\r\nimport { SelectItem } from '@/registry/default/ui/select'\r\n\r\nimport { InsertImageDialog } from '@/registry/default/editor/plugins/images-plugin'\r\n\r\nexport function InsertImage() {\r\n  const { activeEditor, showModal } = useToolbarContext()\r\n\r\n  return (\r\n    <SelectItem\r\n      value=\"image\"\r\n      onPointerUp={(e) => {\r\n        showModal('Insert Image', (onClose) => (\r\n          <InsertImageDialog activeEditor={activeEditor} onClose={onClose} />\r\n        ))\r\n      }}\r\n      className=\"\"\r\n    >\r\n      <div className=\"flex items-center gap-1\">\r\n        <ImageIcon className=\"size-4\" />\r\n        <span>Image</span>\r\n      </div>\r\n    </SelectItem>\r\n  )\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-image.tsx"
    }
  ]
}