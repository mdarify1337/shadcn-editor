{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "collapsible-plugin",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "files": [
    {
      "path": "editor/plugins/collapsible-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport { useEffect } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport {\r\n  $findMatchingParent,\r\n  $insertNodeToNearestRoot,\r\n  mergeRegister,\r\n} from '@lexical/utils'\r\nimport {\r\n  $createParagraphNode,\r\n  $getSelection,\r\n  $isRangeSelection,\r\n  COMMAND_PRIORITY_LOW,\r\n  DELETE_CHARACTER_COMMAND,\r\n  ElementNode,\r\n  INSERT_PARAGRAPH_COMMAND,\r\n  KEY_ARROW_DOWN_COMMAND,\r\n  KEY_ARROW_LEFT_COMMAND,\r\n  KEY_ARROW_RIGHT_COMMAND,\r\n  KEY_ARROW_UP_COMMAND,\r\n  LexicalNode,\r\n  createCommand,\r\n} from 'lexical'\r\n\r\nimport {\r\n  $createCollapsibleContainerNode,\r\n  $isCollapsibleContainerNode,\r\n  CollapsibleContainerNode,\r\n} from '@/registry/default/editor/nodes/collapsible-container-node'\r\nimport {\r\n  $createCollapsibleContentNode,\r\n  $isCollapsibleContentNode,\r\n  CollapsibleContentNode,\r\n} from '@/registry/default/editor/nodes/collapsible-content-node'\r\nimport {\r\n  $createCollapsibleTitleNode,\r\n  $isCollapsibleTitleNode,\r\n  CollapsibleTitleNode,\r\n} from '@/registry/default/editor/nodes/collapsible-title-node'\r\n\r\nexport const INSERT_COLLAPSIBLE_COMMAND = createCommand<void>()\r\n\r\nexport function CollapsiblePlugin(): null {\r\n  const [editor] = useLexicalComposerContext()\r\n\r\n  useEffect(() => {\r\n    if (\r\n      !editor.hasNodes([\r\n        CollapsibleContainerNode,\r\n        CollapsibleTitleNode,\r\n        CollapsibleContentNode,\r\n      ])\r\n    ) {\r\n      throw new Error(\r\n        'CollapsiblePlugin: CollapsibleContainerNode, CollapsibleTitleNode, or CollapsibleContentNode not registered on editor'\r\n      )\r\n    }\r\n\r\n    const $onEscapeUp = () => {\r\n      const selection = $getSelection()\r\n      if (\r\n        $isRangeSelection(selection) &&\r\n        selection.isCollapsed() &&\r\n        selection.anchor.offset === 0\r\n      ) {\r\n        const container = $findMatchingParent(\r\n          selection.anchor.getNode(),\r\n          $isCollapsibleContainerNode\r\n        )\r\n\r\n        if ($isCollapsibleContainerNode(container)) {\r\n          const parent = container.getParent<ElementNode>()\r\n          if (\r\n            parent !== null &&\r\n            parent.getFirstChild<LexicalNode>() === container &&\r\n            selection.anchor.key ===\r\n              container.getFirstDescendant<LexicalNode>()?.getKey()\r\n          ) {\r\n            container.insertBefore($createParagraphNode())\r\n          }\r\n        }\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    const $onEscapeDown = () => {\r\n      const selection = $getSelection()\r\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\r\n        const container = $findMatchingParent(\r\n          selection.anchor.getNode(),\r\n          $isCollapsibleContainerNode\r\n        )\r\n\r\n        if ($isCollapsibleContainerNode(container)) {\r\n          const parent = container.getParent<ElementNode>()\r\n          if (\r\n            parent !== null &&\r\n            parent.getLastChild<LexicalNode>() === container\r\n          ) {\r\n            const titleParagraph = container.getFirstDescendant<LexicalNode>()\r\n            const contentParagraph = container.getLastDescendant<LexicalNode>()\r\n\r\n            if (\r\n              (contentParagraph !== null &&\r\n                selection.anchor.key === contentParagraph.getKey() &&\r\n                selection.anchor.offset ===\r\n                  contentParagraph.getTextContentSize()) ||\r\n              (titleParagraph !== null &&\r\n                selection.anchor.key === titleParagraph.getKey() &&\r\n                selection.anchor.offset === titleParagraph.getTextContentSize())\r\n            ) {\r\n              container.insertAfter($createParagraphNode())\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    return mergeRegister(\r\n      // Structure enforcing transformers for each node type. In case nesting structure is not\r\n      // \"Container > Title + Content\" it'll unwrap nodes and convert it back\r\n      // to regular content.\r\n      editor.registerNodeTransform(CollapsibleContentNode, (node) => {\r\n        const parent = node.getParent<ElementNode>()\r\n        if (!$isCollapsibleContainerNode(parent)) {\r\n          const children = node.getChildren<LexicalNode>()\r\n          for (const child of children) {\r\n            node.insertBefore(child)\r\n          }\r\n          node.remove()\r\n        }\r\n      }),\r\n\r\n      editor.registerNodeTransform(CollapsibleTitleNode, (node) => {\r\n        const parent = node.getParent<ElementNode>()\r\n        if (!$isCollapsibleContainerNode(parent)) {\r\n          node.replace(\r\n            $createParagraphNode().append(...node.getChildren<LexicalNode>())\r\n          )\r\n          return\r\n        }\r\n      }),\r\n\r\n      editor.registerNodeTransform(CollapsibleContainerNode, (node) => {\r\n        const children = node.getChildren<LexicalNode>()\r\n        if (\r\n          children.length !== 2 ||\r\n          !$isCollapsibleTitleNode(children[0]) ||\r\n          !$isCollapsibleContentNode(children[1])\r\n        ) {\r\n          for (const child of children) {\r\n            node.insertBefore(child)\r\n          }\r\n          node.remove()\r\n        }\r\n      }),\r\n\r\n      // This handles the case when container is collapsed and we delete its previous sibling\r\n      // into it, it would cause collapsed content deleted (since it's display: none, and selection\r\n      // swallows it when deletes single char). Instead we expand container, which is although\r\n      // not perfect, but avoids bigger problem\r\n      editor.registerCommand(\r\n        DELETE_CHARACTER_COMMAND,\r\n        () => {\r\n          const selection = $getSelection()\r\n          if (\r\n            !$isRangeSelection(selection) ||\r\n            !selection.isCollapsed() ||\r\n            selection.anchor.offset !== 0\r\n          ) {\r\n            return false\r\n          }\r\n\r\n          const anchorNode = selection.anchor.getNode()\r\n          const topLevelElement = anchorNode.getTopLevelElement()\r\n          if (topLevelElement === null) {\r\n            return false\r\n          }\r\n\r\n          const container = topLevelElement.getPreviousSibling<LexicalNode>()\r\n          if (!$isCollapsibleContainerNode(container) || container.getOpen()) {\r\n            return false\r\n          }\r\n\r\n          container.setOpen(true)\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n\r\n      // When collapsible is the last child pressing down/right arrow will insert paragraph\r\n      // below it to allow adding more content. It's similar what $insertBlockNode\r\n      // (mainly for decorators), except it'll always be possible to continue adding\r\n      // new content even if trailing paragraph is accidentally deleted\r\n      editor.registerCommand(\r\n        KEY_ARROW_DOWN_COMMAND,\r\n        $onEscapeDown,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n\r\n      editor.registerCommand(\r\n        KEY_ARROW_RIGHT_COMMAND,\r\n        $onEscapeDown,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n\r\n      // When collapsible is the first child pressing up/left arrow will insert paragraph\r\n      // above it to allow adding more content. It's similar what $insertBlockNode\r\n      // (mainly for decorators), except it'll always be possible to continue adding\r\n      // new content even if leading paragraph is accidentally deleted\r\n      editor.registerCommand(\r\n        KEY_ARROW_UP_COMMAND,\r\n        $onEscapeUp,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n\r\n      editor.registerCommand(\r\n        KEY_ARROW_LEFT_COMMAND,\r\n        $onEscapeUp,\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n\r\n      // Enter goes from Title to Content rather than a new line inside Title\r\n      editor.registerCommand(\r\n        INSERT_PARAGRAPH_COMMAND,\r\n        () => {\r\n          const selection = $getSelection()\r\n          if ($isRangeSelection(selection)) {\r\n            const titleNode = $findMatchingParent(\r\n              selection.anchor.getNode(),\r\n              (node) => $isCollapsibleTitleNode(node)\r\n            )\r\n\r\n            if ($isCollapsibleTitleNode(titleNode)) {\r\n              const container = titleNode.getParent<ElementNode>()\r\n              if (container && $isCollapsibleContainerNode(container)) {\r\n                if (!container.getOpen()) {\r\n                  container.toggleOpen()\r\n                }\r\n                titleNode.getNextSibling()?.selectEnd()\r\n                return true\r\n              }\r\n            }\r\n          }\r\n\r\n          return false\r\n        },\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        INSERT_COLLAPSIBLE_COMMAND,\r\n        () => {\r\n          editor.update(() => {\r\n            const title = $createCollapsibleTitleNode()\r\n            const paragraph = $createParagraphNode()\r\n            $insertNodeToNearestRoot(\r\n              $createCollapsibleContainerNode(true).append(\r\n                title.append(paragraph),\r\n                $createCollapsibleContentNode().append($createParagraphNode())\r\n              )\r\n            )\r\n            paragraph.select()\r\n          })\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_LOW\r\n      )\r\n    )\r\n  }, [editor])\r\n\r\n  return null\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/collapsible-plugin.tsx"
    }
  ]
}